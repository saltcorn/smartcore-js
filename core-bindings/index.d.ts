/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare class AccuracyF64 {
  constructor()
  getScore(yTrue: Float64Array, yPred: Float64Array): number
}
export type Accuracyf64 = AccuracyF64

export declare class AccuracyI64 {
  constructor()
  getScore(yTrue: BigInt64Array, yPred: BigInt64Array): number
}
export type Accuracyi64 = AccuracyI64

export declare class AUCF64 {
  constructor()
  getScore(yTrue: Float64Array, yPred: Float64Array): number
}
export type AUCf64 = AUCF64

export declare class BernoulliNBF64U64 {
  static fit(x: DenseMatrixF64, y: BigUint64Array, parameters: BernoulliNBParametersF64): BernoulliNBF64U64
  predict(x: DenseMatrixF64): BigUint64Array
  serialize(): Buffer
  static deserialize(data: Buffer): BernoulliNBF64U64
}

export declare class BernoulliNBParametersF64 {
  constructor()
  withPriors(priors: Float64Array): void
  withAlpha(alpha: number): void
  withBinarize(binarize: number): void
}

export declare class Boston {
  loadDataset(): DatasetF64F64
}

export declare class BreastCancer {
  loadDataset(): DatasetF64I64
}

export declare class CategoricalNBParameters {
  constructor()
  withAlpha(alpha: number): void
}

export declare class CategoricalNBU64 {
  static fit(x: DenseMatrixU64, y: BigUint64Array, parameters: CategoricalNBParameters): CategoricalNBU64
  predict(x: DenseMatrixU64): BigUint64Array
  serialize(): Buffer
  static deserialize(data: Buffer): CategoricalNBU64
}

export declare class CrossValidationResult {
  testScore(): Float64Array
  trainScore(): Float64Array
  meanTestScore(): number
  meanTrainScore(): number
}

export declare class dataset {
  static boston(): Boston
  static breastCancer(): BreastCancer
  static diabetes(): Diabetes
  static digits(): Digits
  static generator(): Generator
  static iris(): Iris
}
export type Dataset = dataset

export declare class DatasetF64F64 {
  get data(): Float64Array
  get target(): Float64Array
  get numSamples(): number
  get numFeatures(): number
  get featureNames(): Array<string>
  get targetNames(): Array<string>
  get description(): string
  denseMatrix(columnMajor?: boolean | undefined | null): DenseMatrixF64
}

export declare class DatasetF64F64JsVecRef {
  asArray(): Float64Array
}

export declare class DatasetF64I64 {
  get data(): Float64Array
  get target(): BigInt64Array
  get numSamples(): number
  get numFeatures(): number
  get featureNames(): Array<string>
  get targetNames(): Array<string>
  get description(): string
  denseMatrix(columnMajor?: boolean | undefined | null): DenseMatrixF64
}

export declare class DatasetF64I64JsVecRef {
  asArray(): BigInt64Array
}

export declare class DBSCANF64F64 {
  static fit(x: DenseMatrixF64, parameters: EuclidianF64DBSCANF64Parameters): DBSCANF64F64
  predict(x: DenseMatrixF64): Float64Array
}

export declare class DecisionTreeClassifierI64I64 {
  static fit(x: DenseMatrixI64, y: BigInt64Array, parameters: DecisionTreeClassifierParameters): DecisionTreeClassifierI64I64
  predict(x: DenseMatrixI64): BigInt64Array
  serialize(): Buffer
  static deserialize(data: Buffer): DecisionTreeClassifierI64I64
}

export declare class DecisionTreeClassifierParameters {
  constructor()
  withCriterion(criterion: SplitCriterion): void
  withMaxDepth(maxDepth: number): void
  withMinSamplesLeaf(minSamplesLeaf: bigint): void
  withMinSamplesSplit(minSamplesSplit: bigint): void
}

export declare class DecisionTreeRegressorI64I64 {
  static fit(x: DenseMatrixI64, y: BigInt64Array, parameters: DecisionTreeRegressorParameters): DecisionTreeRegressorI64I64
  predict(x: DenseMatrixI64): BigInt64Array
  serialize(): Buffer
  static deserialize(data: Buffer): DecisionTreeRegressorI64I64
}

export declare class DecisionTreeRegressorParameters {
  constructor()
  withMaxDepth(maxDepth: number): void
  withMinSamplesLeaf(minSamplesLeaf: bigint): void
  withMinSamplesSplit(minSamplesSplit: bigint): void
}

export declare class DenseMatrixF64 {
  constructor(nrows: number, ncols: number, values: Float64Array, columnMajor?: boolean | undefined | null)
  serialize(): Buffer
  static deserialize(data: Buffer): DenseMatrixF64
  static fill(nrows: number, ncols: number, value: number): DenseMatrixF64
  slice(): DenseMatrixF64
  sliceMut(): DenseMatrixF64
  fromIterator(): DenseMatrixF64
  getRow(row: number): JsBoxedArrayF64Ref
  getCol(col: number): JsBoxedArrayF64Ref
  static zeros(nrows: number, ncols: number): DenseMatrixF64
  static ones(nrows: number, ncols: number): DenseMatrixF64
  static eye(size: number): DenseMatrixF64
  static rand(nrows: number, ncols: number): DenseMatrixF64
  static fromSlice(slice: DenseMatrixF64): DenseMatrixF64
  static fromRow(slice: Float64Array): DenseMatrixF64
  static fromColumn(slice: Float64Array): DenseMatrixF64
  transpose(): DenseMatrixF64
  reshape(nrows: number, ncols: number, axis: number): DenseMatrixF64
  matmul(other: DenseMatrixF64): DenseMatrixF64
  ab(aTranspose: boolean, b: DenseMatrixF64, bTranspose: boolean): DenseMatrixF64
  ax(aTranspose: boolean, b: Float64Array): DenseMatrixF64
  static concatenate1D(): DenseMatrixF64
  static concatenate2D(): DenseMatrixF64
  merge1D(): DenseMatrixF64
  vStack(other: DenseMatrixF64): DenseMatrixF64
  hStack(other: DenseMatrixF64): DenseMatrixF64
  map(): DenseMatrixF64
  rowIter(): DenseMatrixF64
  colIter(): DenseMatrixF64
  take(index: BigInt64Array, axis: number): DenseMatrixF64
  takeColumn(columnIndex: number): DenseMatrixF64
  addScalar(x: number): DenseMatrixF64
  subScalar(x: number): DenseMatrixF64
  divScalar(x: number): DenseMatrixF64
  mulScalar(x: number): DenseMatrixF64
  add(other: DenseMatrixF64): DenseMatrixF64
  sub(other: DenseMatrixF64): DenseMatrixF64
  mul(other: DenseMatrixF64): DenseMatrixF64
  div(other: DenseMatrixF64): DenseMatrixF64
  abs(): DenseMatrixF64
  neg(): DenseMatrixF64
  pow(p: number): DenseMatrixF64
  columnMean(): Float64Array
  copyColAsVec(): DenseMatrixF64
  approximateEq(other: DenseMatrixF64, error: number): boolean
  svdSolve(b: DenseMatrixF64): DenseMatrixF64
  svd(): SVDF64DenseMatrixF64
}

export declare class DenseMatrixI64 {
  constructor(nrows: number, ncols: number, values: Array<number>, columnMajor?: boolean | undefined | null)
  serialize(): Buffer
  static deserialize(data: Buffer): DenseMatrixI64
}

export declare class DenseMatrixU64 {
  constructor(nrows: number, ncols: number, values: BigUint64Array, columnMajor?: boolean | undefined | null)
  serialize(): Buffer
  static deserialize(data: Buffer): DenseMatrixU64
}

export declare class Diabetes {
  loadDataset(): DatasetF64I64
}

export declare class Digits {
  loadDataset(): DatasetF64F64
}

export declare class ElasticNetF64F64 {
  constructor()
  static fit(x: DenseMatrixF64, y: Float64Array, parameters: ElasticNetParameters): ElasticNetF64F64
  predict(x: DenseMatrixF64): Float64Array
  serialize(): Buffer
  static deserialize(data: Buffer): ElasticNetF64F64
}

export declare class ElasticNetF64I64 {
  constructor()
  static fit(x: DenseMatrixF64, y: BigInt64Array, parameters: ElasticNetParameters): ElasticNetF64I64
  predict(x: DenseMatrixF64): BigInt64Array
  serialize(): Buffer
  static deserialize(data: Buffer): ElasticNetF64I64
}

export declare class ElasticNetParameters {
  constructor()
  withAlpha(alpha: number): void
  withL1Ratio(l1Ratio: number): void
  withNormalize(normalize: boolean): void
  withTol(tol: number): void
  withMaxIter(maxIter: number): void
}

export declare class Euclidianf64 {
  constructor()
  distance(x: Float64Array, y: Float64Array): number
}
export type EuclidianF64 = Euclidianf64

export declare class EuclidianF64DBSCANF64Parameters {
  withMinSamples(minSamples: number): void
  withAlgorithm(algorithm: KNNAlgorithmName): void
  withEps(eps: number): void
  constructor()
  static withDistanceHammingF64(distance: HammingF64): EuclidianF64DBSCANF64Parameters
}

export declare class Euclidiani64 {
  constructor()
  distance(x: BigInt64Array, y: BigInt64Array): number
}
export type EuclidianI64 = Euclidiani64

export declare class ExtraTreesRegressorF64F64 {
  static fit(x: DenseMatrixF64, y: Float64Array, parameters: ExtraTreesRegressorParameters): ExtraTreesRegressorF64F64
  predict(x: DenseMatrixF64): Float64Array
  serialize(): Buffer
  static deserialize(data: Buffer): ExtraTreesRegressorF64F64
}

export declare class ExtraTreesRegressorF64I64 {
  static fit(x: DenseMatrixF64, y: BigInt64Array, parameters: ExtraTreesRegressorParameters): ExtraTreesRegressorF64I64
  predict(x: DenseMatrixF64): BigInt64Array
  serialize(): Buffer
  static deserialize(data: Buffer): ExtraTreesRegressorF64I64
}

export declare class ExtraTreesRegressorParameters {
  constructor()
  withMaxDepth(maxDepth: number): void
  withMinSamplesLeaf(minSamplesLeaf: bigint): void
  withMinSamplesSplit(minSamplesSplit: bigint): void
  withNTrees(nTrees: number): void
  withM(m: number): void
  withKeepSamples(keepSamples: boolean): void
  withSeed(seed: number): void
}

export declare class F1F64 {
  constructor()
  getScore(yTrue: Float64Array, yPred: Float64Array): number
}
export type F1f64 = F1F64

export declare class GaussianNBF64U64 {
  static fit(x: DenseMatrixF64, y: BigUint64Array, parameters: GaussianNBParameters): GaussianNBF64U64
  predict(x: DenseMatrixF64): BigUint64Array
  serialize(): Buffer
  static deserialize(data: Buffer): GaussianNBF64U64
}

export declare class GaussianNBParameters {
  constructor()
  withPriors(priors: Float64Array): void
}

export declare class Generator {
  makeBlobs(numSamples: number, numFeatures: number, numCenters: number): DatasetF64F64
  makeCircles(numSamples: number, factor: number, noise: number): DatasetF64I64
  makeMoons(numSamples: number, noise: number): DatasetF64I64
}

export declare class HammingF64 {
  constructor()
  distance(x: Float64Array, y: Float64Array): number
}

export declare class HammingF64DBSCANF64Parameters {
  withMinSamples(minSamples: number): void
  withAlgorithm(algorithm: KNNAlgorithmName): void
  withEps(eps: number): void
}

export declare class HammingI64 {
  constructor()
  distance(x: BigInt64Array, y: BigInt64Array): number
}

export declare class HCVScoreI64 {
  constructor()
  getScore(yTrue: BigInt64Array, yPred: BigInt64Array): number
}
export type HCVScorei64 = HCVScoreI64

export declare class Iris {
  loadDataset(): DatasetF64I64
}

export declare class JsBoxedArrayF32Ref {

}

export declare class JsBoxedArrayF64Ref {

}

export declare class JsDenseMatrixF64Ref {
  matmul(other: JsDenseMatrixF64Ref): DenseMatrixF64
  transpose(): DenseMatrixF64
}

export declare class JsVecF64Ref {

}

export declare class JsVecI64Ref {

}

export declare class Kernels {
  static linear(): Kernels
  static rbf(gamma: number): Kernels
  static polynomial(gamma: number, degree: number): Kernels
  static sigmoid(gamma: number, coef0: number): Kernels
}

export declare class KFold {
  constructor()
  withNSplits(nSplits: number): void
}

export declare class KMeansF64F64 {
  static fit(x: DenseMatrixF64, parameters: KMeansParameters): KMeansF64F64
  predict(x: DenseMatrixF64): Float64Array
  serialize(): Buffer
  static deserialize(data: Buffer): KMeansF64F64
}

export declare class KMeansF64I64 {
  static fit(x: DenseMatrixF64, parameters: KMeansParameters): KMeansF64I64
  predict(x: DenseMatrixF64): BigInt64Array
  serialize(): Buffer
  static deserialize(data: Buffer): KMeansF64I64
}

export declare class KMeansParameters {
  constructor()
  withMaxIter(maxIter: number): void
  withK(k: number): void
}

export declare class KNNClassifierF64I64 {
  static fit(x: DenseMatrixF64, y: BigInt64Array): KNNClassifierF64I64
  predict(x: DenseMatrixF64): BigInt64Array
  serialize(): Buffer
  static deserialize(data: Buffer): KNNClassifierF64I64
}

export declare class KNNRegressorF64F64 {
  static fit(x: DenseMatrixF64, y: Float64Array): KNNRegressorF64F64
  predict(x: DenseMatrixF64): Float64Array
  serialize(): Buffer
  static deserialize(data: Buffer): KNNRegressorF64F64
}

export declare class KNNRegressorF64I64 {
  static fit(x: DenseMatrixF64, y: BigInt64Array): KNNRegressorF64I64
  predict(x: DenseMatrixF64): BigInt64Array
  serialize(): Buffer
  static deserialize(data: Buffer): KNNRegressorF64I64
}

export declare class KNNRegressorParametersF64EuclidianF64 {
  withK(k: number): void
  withAlgorithm(algorithm: KNNAlgorithmName): void
  withWeight(weight: KNNWeightFunction): void
  constructor()
  static withDistanceHammingF64(distance: HammingF64): KNNRegressorParametersF64EuclidianF64
}
export type EuclidianF64KNNRegressorParametersF64 = KNNRegressorParametersF64EuclidianF64

export declare class KNNRegressorParametersF64HammingF64 {
  withK(k: number): void
  withAlgorithm(algorithm: KNNAlgorithmName): void
  withWeight(weight: KNNWeightFunction): void
}
export type HammingF64KNNRegressorParametersF64 = KNNRegressorParametersF64HammingF64

export declare class LassoF64F64 {
  constructor()
  static fit(x: DenseMatrixF64, y: Float64Array, parameters: LassoParameters): LassoF64F64
  predict(x: DenseMatrixF64): Float64Array
  serialize(): Buffer
  static deserialize(data: Buffer): LassoF64F64
}

export declare class LassoF64I64 {
  constructor()
  static fit(x: DenseMatrixF64, y: BigInt64Array, parameters: LassoParameters): LassoF64I64
  predict(x: DenseMatrixF64): BigInt64Array
  serialize(): Buffer
  static deserialize(data: Buffer): LassoF64I64
}

export declare class LassoParameters {
  constructor()
  withAlpha(alpha: number): void
  withNormalize(normalize: boolean): void
  withTol(tol: number): void
  withMaxIter(maxIter: number): void
}

export declare class LinearRegressionF64F64 {
  constructor()
  static fit(x: DenseMatrixF64, y: Float64Array, parameters: LinearRegressionParameters): LinearRegressionF64F64
  serialize(): Buffer
  static deserialize(data: Buffer): LinearRegressionF64F64
  predict(x: DenseMatrixF64): Float64Array
}

export declare class LinearRegressionF64I64 {
  constructor()
  static fit(x: DenseMatrixF64, y: Array<number>, parameters: LinearRegressionParameters): LinearRegressionF64I64
  serialize(): Buffer
  static deserialize(data: Buffer): LinearRegressionF64I64
  predict(x: DenseMatrixF64): Array<number>
}

export declare class LinearRegressionParameters {
  constructor()
  withSolver(solver: LinearRegressionSolverName): void
}

export declare class LogisticRegressionF64I64 {
  constructor()
  static fit(x: DenseMatrixF64, y: BigInt64Array, parameters: LogisticRegressionParametersF64): LogisticRegressionF64I64
  predict(x: DenseMatrixF64): BigInt64Array
  serialize(): Buffer
  static deserialize(data: Buffer): LogisticRegressionF64I64
}

export declare class LogisticRegressionParametersF64 {
  constructor()
  withAlpha(alpha: number): void
  withSolver(solver: LogisticRegressionSolverName): void
}

export declare class MahalanobisF64 {
  constructor(data: DenseMatrixF64)
  distance(x: Float64Array, y: Float64Array): number
}

export declare class ManhattanF64 {
  constructor()
  distance(x: Float64Array, y: Float64Array): number
}

export declare class ManhattanI64 {
  constructor()
  distance(x: BigInt64Array, y: BigInt64Array): number
}

export declare class MeanAbsoluteErrorF64 {
  constructor()
  getScore(yTrue: Float64Array, yPred: Float64Array): number
}
export type MeanAbsoluteErrorf64 = MeanAbsoluteErrorF64

export declare class MeanSquareErrorF64 {
  constructor()
  getScore(yTrue: Float64Array, yPred: Float64Array): number
}
export type MeanSquareErrorf64 = MeanSquareErrorF64

export declare class MinkowskiF64 {
  constructor(p: number)
  distance(x: Float64Array, y: Float64Array): number
}

export declare class MinkowskiI64 {
  constructor(p: number)
  distance(x: BigInt64Array, y: BigInt64Array): number
}

export declare class MultinomialNBParameters {
  constructor()
  withAlpha(alpha: number): void
  withPriors(priors: Float64Array): void
}

export declare class MultinomialNBU64U64 {
  static fit(x: DenseMatrixU64, y: BigUint64Array, parameters: MultinomialNBParameters): MultinomialNBU64U64
  predict(x: DenseMatrixU64): BigUint64Array
  serialize(): Buffer
  static deserialize(data: Buffer): MultinomialNBU64U64
}

export declare class PCAF64 {
  constructor(data: DenseMatrixF64, parameters: PCAParameters)
  transform(x: DenseMatrixF64): DenseMatrixF64
  serialize(): Buffer
  static deserialize(data: Buffer): PCAF64
}

export declare class PCAParameters {
  constructor()
  withNComponents(nComponents: number): void
  set useCorrelationMatrix(useCorrelationMatrix: boolean)
}

export declare class PrecisionF64 {
  constructor()
  getScore(yTrue: Float64Array, yPred: Float64Array): number
}
export type Precisionf64 = PrecisionF64

export declare class R2F64 {
  constructor()
  getScore(yTrue: Float64Array, yPred: Float64Array): number
}
export type R2f64 = R2F64

export declare class R2I64 {
  constructor()
  getScore(yTrue: BigInt64Array, yPred: BigInt64Array): number
}
export type R2i64 = R2I64

export declare class RandomForestClassifierF64I64 {
  static fit(x: DenseMatrixF64, y: Array<number>, parameters: RandomForestClassifierParameters): RandomForestClassifierF64I64
  serialize(): Buffer
  static deserialize(data: Buffer): RandomForestClassifierF64I64
  predict(x: DenseMatrixF64): Array<number>
}

export declare class RandomForestClassifierParameters {
  constructor()
  withCriterion(criterion: SplitCriterion): void
  withMaxDepth(maxDepth: number): void
  withMinSamplesLeaf(minSamplesLeaf: bigint): void
  withMinSamplesSplit(minSamplesSplit: bigint): void
  withNTrees(nTrees: number): void
  withM(m: number): void
  withKeepSamples(keepSamples: boolean): void
  withSeed(seed: number): void
}

export declare class RandomForestRegressorF64F64 {
  static fit(x: DenseMatrixF64, y: Float64Array, parameters: RandomForestRegressorParameters): RandomForestRegressorF64F64
  predict(x: DenseMatrixF64): Float64Array
  serialize(): Buffer
  static deserialize(data: Buffer): RandomForestRegressorF64F64
}

export declare class RandomForestRegressorF64I64 {
  static fit(x: DenseMatrixF64, y: BigInt64Array, parameters: RandomForestRegressorParameters): RandomForestRegressorF64I64
  predict(x: DenseMatrixF64): BigInt64Array
  serialize(): Buffer
  static deserialize(data: Buffer): RandomForestRegressorF64I64
}

export declare class RandomForestRegressorParameters {
  constructor()
  withMaxDepth(maxDepth: number): void
  withMinSamplesLeaf(minSamplesLeaf: bigint): void
  withMinSamplesSplit(minSamplesSplit: bigint): void
  withNTrees(nTrees: number): void
  withM(m: number): void
  withKeepSamples(keepSamples: boolean): void
  withSeed(seed: number): void
}

export declare class RecallF64 {
  constructor()
  getScore(yTrue: Float64Array, yPred: Float64Array): number
}
export type Recallf64 = RecallF64

export declare class RidgeRegressionF64F64 {
  constructor()
  static fit(x: DenseMatrixF64, y: Float64Array, parameters: RidgeRegressionParametersF64): RidgeRegressionF64F64
  predict(x: DenseMatrixF64): Float64Array
  serialize(): Buffer
  static deserialize(data: Buffer): RidgeRegressionF64F64
}

export declare class RidgeRegressionParametersF64 {
  constructor()
  withAlpha(alpha: number): void
  withNormalize(normalize: boolean): void
  withSolver(solver: RidgeRegressionSolverName): void
}

export declare class SVCF64I64 {
  static setFitData(xRef: DenseMatrixF64, yRef: BigInt64Array, parametersRef: SVCParametersF64I64): SVCF64I64
  fit(): void
  predict(xRef: DenseMatrixF64): Float64Array
  serialize(): Buffer
  static deserialize(data: Buffer): SVCF64I64
}

export declare class SVCParametersF64I64 {
  constructor()
  withEpoch(epoch: number): void
  withC(c: number): void
  withTol(tol: number): void
  withSeed(seed?: bigint | undefined | null): void
}

export declare class SVDF64 {
  constructor(data: DenseMatrixF64, parameters: SVDParameters)
  transform(x: DenseMatrixF64): DenseMatrixF64
  serialize(): Buffer
  static deserialize(data: Buffer): SVDF64
}

export declare class SVDF64DenseMatrixF64 {
  U(): JsDenseMatrixF64Ref
  V(): JsDenseMatrixF64Ref
  S(): DenseMatrixF64
}

export declare class SVDParameters {
  constructor()
  withNComponents(nComponents: number): void
}

export declare class SVRF64 {
  static setFitData(xRef: DenseMatrixF64, yRef: Float64Array, parametersRef: SVRParametersF64): SVRF64
  fit(): void
  predict(xRef: DenseMatrixF64): Float64Array
  serialize(): Buffer
  static deserialize(data: Buffer): SVRF64
}

export declare class SVRParametersF64 {
  constructor()
  withEps(eps: number): void
  withC(c: number): void
  withTol(tol: number): void
  withKernel(kernel: Kernels): void
}

export declare class VecF64 {
  constructor(values: Float64Array)
}

export declare class VecI64 {
  constructor(values: BigInt64Array)
}

export declare function crossValidateElasticNetF64F64(xs: DenseMatrixF64, ys: Float64Array, parameters: ElasticNetParameters, cv: KFold, score: (arg0: Float64Array, arg1: Float64Array) => number): CrossValidationResult

export declare function crossValidateElasticNetF64I64(xs: DenseMatrixF64, ys: BigInt64Array, parameters: ElasticNetParameters, cv: KFold, score: (arg0: BigInt64Array, arg1: BigInt64Array) => number): CrossValidationResult

export declare function crossValidateLogisticRegressionF64I64(xs: DenseMatrixF64, ys: BigInt64Array, parameters: LogisticRegressionParametersF64, cv: KFold, score: (arg0: BigInt64Array, arg1: BigInt64Array) => number): CrossValidationResult

export declare const enum KNNAlgorithmName {
  LinearSearch = 0,
  CoverTree = 1
}

export declare const enum KNNWeightFunction {
  Uniform = 0,
  Distance = 1
}

export declare const enum LinearRegressionSolverName {
  Qr = 0,
  Svd = 1
}

export declare const enum LogisticRegressionSolverName {
  LBFGS = 0
}

export declare const enum RidgeRegressionSolverName {
  Cholesky = 0,
  Svd = 1
}

export declare const enum SplitCriterion {
  Gini = 0,
  Entropy = 1,
  ClassificationError = 2
}

export declare function trainTestSplitF64F64(x: DenseMatrixF64, y: Float64Array, testSize: number, shuffle: boolean, seed?: bigint | undefined | null): [DenseMatrixF64, DenseMatrixF64, Float64Array, Float64Array]

export declare function trainTestSplitF64I64(x: DenseMatrixF64, y: BigInt64Array, testSize: number, shuffle: boolean, seed?: bigint | undefined | null): [DenseMatrixF64, DenseMatrixF64, BigInt64Array, BigInt64Array]
