/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare class AccuracyF32 {
  constructor()
  getScore(yTrue: Float32Array, yPred: Float32Array): number
}
export type Accuracyf32 = AccuracyF32

export declare class AccuracyF64 {
  constructor()
  getScore(yTrue: Float64Array, yPred: Float64Array): number
}
export type Accuracyf64 = AccuracyF64

export declare class AccuracyU32 {
  constructor()
  getScore(yTrue: Uint32Array, yPred: Uint32Array): number
}
export type Accuracyu32 = AccuracyU32

export declare class AUCF32 {
  constructor()
  getScore(yTrue: Float32Array, yPred: Float32Array): number
}
export type AUCf32 = AUCF32

export declare class AUCF64 {
  constructor()
  getScore(yTrue: Float64Array, yPred: Float64Array): number
}
export type AUCf64 = AUCF64

export declare class BernoulliNBParametersF32 {
  constructor()
  withPriors(priors: Float64Array): void
  withAlpha(alpha: number): void
  withBinarize(binarize: number): void
}

export declare class BernoulliNBParametersF64 {
  constructor()
  withPriors(priors: Float64Array): void
  withAlpha(alpha: number): void
  withBinarize(binarize: number): void
}

export declare class Boston {
  loadDataset(): DatasetF32F32
}

export declare class BreastCancer {
  loadDataset(): DatasetF32U32
}

export declare class CategoricalNBParameters {
  constructor()
  withAlpha(alpha: number): void
}

export declare class CategoricalNBU32 {
  static fit(x: DenseMatrixU32, y: Uint32Array, parameters: CategoricalNBParameters): CategoricalNBU32
  predict(x: DenseMatrixU32): Uint32Array
  serialize(): Buffer
  static deserialize(data: Buffer): CategoricalNBU32
}

export declare class CategoricalNBU64 {
  static fit(x: DenseMatrixU64, y: BigUint64Array, parameters: CategoricalNBParameters): CategoricalNBU64
  predict(x: DenseMatrixU64): BigUint64Array
  serialize(): Buffer
  static deserialize(data: Buffer): CategoricalNBU64
}

export declare class CrossValidationResult {
  testScore(): Float64Array
  trainScore(): Float64Array
  meanTestScore(): number
  meanTrainScore(): number
}

export declare class dataset {
  static boston(): Boston
  static breastCancer(): BreastCancer
  static diabetes(): Diabetes
  static digits(): Digits
  static generator(): Generator
  static iris(): Iris
}
export type Dataset = dataset

export declare class DatasetF32F32 {
  get data(): Float32Array
  get target(): DatasetF32F32JsVecRef
  get numSamples(): number
  get numFeatures(): number
  get featureNames(): Array<string>
  get targetNames(): Array<string>
  get description(): string
  denseMatrix(columnMajor?: boolean | undefined | null): DenseMatrixF32
}

export declare class DatasetF32F32JsVecRef {

}

export declare class DatasetF32U32 {
  get data(): Float32Array
  get target(): DatasetF32U32JsVecRef
  get numSamples(): number
  get numFeatures(): number
  get featureNames(): Array<string>
  get targetNames(): Array<string>
  get description(): string
  denseMatrix(columnMajor?: boolean | undefined | null): DenseMatrixF32
}

export declare class DatasetF32U32JsVecRef {

}

export declare class DBSCANF32F32 {
  static fit(x: DenseMatrixF32, parameters: EuclidianF32DBSCANF32Parameters): DBSCANF32F32
  predict(x: DenseMatrixF32): Float32Array
}

export declare class DecisionTreeClassifierParameters {
  constructor()
  withCriterion(criterion: SplitCriterion): void
  withMaxDepth(maxDepth: number): void
  withMinSamplesLeaf(minSamplesLeaf: bigint): void
  withMinSamplesSplit(minSamplesSplit: bigint): void
}

export declare class DecisionTreeClassifierU32U32 {
  static fit(x: DenseMatrixU32, y: Uint32Array, parameters: DecisionTreeClassifierParameters): DecisionTreeClassifierU32U32
  predict(x: DenseMatrixU32): Uint32Array
  serialize(): Buffer
  static deserialize(data: Buffer): DecisionTreeClassifierU32U32
}

export declare class DecisionTreeClassifierU32U64 {
  static fit(x: DenseMatrixU32, y: BigUint64Array, parameters: DecisionTreeClassifierParameters): DecisionTreeClassifierU32U64
  predict(x: DenseMatrixU32): BigUint64Array
  serialize(): Buffer
  static deserialize(data: Buffer): DecisionTreeClassifierU32U64
}

export declare class DecisionTreeClassifierU64U32 {
  static fit(x: DenseMatrixU64, y: Uint32Array, parameters: DecisionTreeClassifierParameters): DecisionTreeClassifierU64U32
  predict(x: DenseMatrixU64): Uint32Array
  serialize(): Buffer
  static deserialize(data: Buffer): DecisionTreeClassifierU64U32
}

export declare class DecisionTreeClassifierU64U64 {
  static fit(x: DenseMatrixU64, y: BigUint64Array, parameters: DecisionTreeClassifierParameters): DecisionTreeClassifierU64U64
  predict(x: DenseMatrixU64): BigUint64Array
  serialize(): Buffer
  static deserialize(data: Buffer): DecisionTreeClassifierU64U64
}

export declare class DecisionTreeRegressorParameters {
  constructor()
  withMaxDepth(maxDepth: number): void
  withMinSamplesLeaf(minSamplesLeaf: bigint): void
  withMinSamplesSplit(minSamplesSplit: bigint): void
}

export declare class DecisionTreeRegressorU32U32 {
  static fit(x: DenseMatrixU32, y: Uint32Array, parameters: DecisionTreeRegressorParameters): DecisionTreeRegressorU32U32
  predict(x: DenseMatrixU32): Uint32Array
  serialize(): Buffer
  static deserialize(data: Buffer): DecisionTreeRegressorU32U32
}

export declare class DecisionTreeRegressorU32U64 {
  static fit(x: DenseMatrixU32, y: BigUint64Array, parameters: DecisionTreeRegressorParameters): DecisionTreeRegressorU32U64
  predict(x: DenseMatrixU32): BigUint64Array
  serialize(): Buffer
  static deserialize(data: Buffer): DecisionTreeRegressorU32U64
}

export declare class DecisionTreeRegressorU64U32 {
  static fit(x: DenseMatrixU64, y: Uint32Array, parameters: DecisionTreeRegressorParameters): DecisionTreeRegressorU64U32
  predict(x: DenseMatrixU64): Uint32Array
  serialize(): Buffer
  static deserialize(data: Buffer): DecisionTreeRegressorU64U32
}

export declare class DecisionTreeRegressorU64U64 {
  static fit(x: DenseMatrixU64, y: BigUint64Array, parameters: DecisionTreeRegressorParameters): DecisionTreeRegressorU64U64
  predict(x: DenseMatrixU64): BigUint64Array
  serialize(): Buffer
  static deserialize(data: Buffer): DecisionTreeRegressorU64U64
}

export declare class DenseMatrixF32 {
  constructor(nrows: number, ncols: number, values: Float32Array, columnMajor?: boolean | undefined | null)
  serialize(): Buffer
  static deserialize(data: Buffer): DenseMatrixF32
  static fill(nrows: number, ncols: number, value: number): DenseMatrixF32
  slice(): DenseMatrixF32
  sliceMut(): DenseMatrixF32
  fromIterator(): DenseMatrixF32
  getRow(row: number): JsBoxedArrayF32Ref
  getCol(col: number): JsBoxedArrayF32Ref
  static zeros(nrows: number, ncols: number): DenseMatrixF32
  static ones(nrows: number, ncols: number): DenseMatrixF32
  static eye(size: number): DenseMatrixF32
  static rand(nrows: number, ncols: number): DenseMatrixF32
  static fromSlice(slice: DenseMatrixF32): DenseMatrixF32
  static fromRow(slice: Float32Array): DenseMatrixF32
  static fromColumn(slice: Float32Array): DenseMatrixF32
  transpose(): DenseMatrixF32
  reshape(nrows: number, ncols: number, axis: number): DenseMatrixF32
  matmul(other: DenseMatrixF32): DenseMatrixF32
  ab(aTranspose: boolean, b: DenseMatrixF32, bTranspose: boolean): DenseMatrixF32
  ax(aTranspose: boolean, b: Float32Array): DenseMatrixF32
  static concatenate1D(): DenseMatrixF32
  static concatenate2D(): DenseMatrixF32
  merge1D(): DenseMatrixF32
  vStack(other: DenseMatrixF32): DenseMatrixF32
  hStack(other: DenseMatrixF32): DenseMatrixF32
  map(): DenseMatrixF32
  rowIter(): DenseMatrixF32
  colIter(): DenseMatrixF32
  take(index: BigInt64Array, axis: number): DenseMatrixF32
  takeColumn(columnIndex: number): DenseMatrixF32
  addScalar(x: number): DenseMatrixF32
  subScalar(x: number): DenseMatrixF32
  divScalar(x: number): DenseMatrixF32
  mulScalar(x: number): DenseMatrixF32
  add(other: DenseMatrixF32): DenseMatrixF32
  sub(other: DenseMatrixF32): DenseMatrixF32
  mul(other: DenseMatrixF32): DenseMatrixF32
  div(other: DenseMatrixF32): DenseMatrixF32
  abs(): DenseMatrixF32
  neg(): DenseMatrixF32
  pow(p: number): DenseMatrixF32
  columnMean(): Float64Array
  copyColAsVec(): DenseMatrixF32
  approximateEq(other: DenseMatrixF32, error: number): boolean
  svdSolve(b: DenseMatrixF32): DenseMatrixF32
  svd(): SVDF32DenseMatrixF32
}

export declare class DenseMatrixF64 {
  constructor(nrows: number, ncols: number, values: Float64Array, columnMajor?: boolean | undefined | null)
  serialize(): Buffer
  static deserialize(data: Buffer): DenseMatrixF64
  static fill(nrows: number, ncols: number, value: number): DenseMatrixF64
  slice(): DenseMatrixF64
  sliceMut(): DenseMatrixF64
  fromIterator(): DenseMatrixF64
  getRow(row: number): JsBoxedArrayF64Ref
  getCol(col: number): JsBoxedArrayF64Ref
  static zeros(nrows: number, ncols: number): DenseMatrixF64
  static ones(nrows: number, ncols: number): DenseMatrixF64
  static eye(size: number): DenseMatrixF64
  static rand(nrows: number, ncols: number): DenseMatrixF64
  static fromSlice(slice: DenseMatrixF64): DenseMatrixF64
  static fromRow(slice: Float64Array): DenseMatrixF64
  static fromColumn(slice: Float64Array): DenseMatrixF64
  transpose(): DenseMatrixF64
  reshape(nrows: number, ncols: number, axis: number): DenseMatrixF64
  matmul(other: DenseMatrixF64): DenseMatrixF64
  ab(aTranspose: boolean, b: DenseMatrixF64, bTranspose: boolean): DenseMatrixF64
  ax(aTranspose: boolean, b: Float64Array): DenseMatrixF64
  static concatenate1D(): DenseMatrixF64
  static concatenate2D(): DenseMatrixF64
  merge1D(): DenseMatrixF64
  vStack(other: DenseMatrixF64): DenseMatrixF64
  hStack(other: DenseMatrixF64): DenseMatrixF64
  map(): DenseMatrixF64
  rowIter(): DenseMatrixF64
  colIter(): DenseMatrixF64
  take(index: BigInt64Array, axis: number): DenseMatrixF64
  takeColumn(columnIndex: number): DenseMatrixF64
  addScalar(x: number): DenseMatrixF64
  subScalar(x: number): DenseMatrixF64
  divScalar(x: number): DenseMatrixF64
  mulScalar(x: number): DenseMatrixF64
  add(other: DenseMatrixF64): DenseMatrixF64
  sub(other: DenseMatrixF64): DenseMatrixF64
  mul(other: DenseMatrixF64): DenseMatrixF64
  div(other: DenseMatrixF64): DenseMatrixF64
  abs(): DenseMatrixF64
  neg(): DenseMatrixF64
  pow(p: number): DenseMatrixF64
  columnMean(): Float64Array
  copyColAsVec(): DenseMatrixF64
  approximateEq(other: DenseMatrixF64, error: number): boolean
  svdSolve(b: DenseMatrixF64): DenseMatrixF64
  svd(): SVDF64DenseMatrixF64
}

export declare class DenseMatrixU32 {
  constructor(nrows: number, ncols: number, values: Uint32Array, columnMajor?: boolean | undefined | null)
  serialize(): Buffer
  static deserialize(data: Buffer): DenseMatrixU32
}

export declare class DenseMatrixU64 {
  constructor(nrows: number, ncols: number, values: BigUint64Array, columnMajor?: boolean | undefined | null)
  serialize(): Buffer
  static deserialize(data: Buffer): DenseMatrixU64
}

export declare class Diabetes {
  loadDataset(): DatasetF32U32
}

export declare class Digits {
  loadDataset(): DatasetF32F32
}

export declare class ElasticNetF32F32 {
  constructor()
  static fit(x: DenseMatrixF32, y: Float32Array, parameters: ElasticNetParameters): ElasticNetF32F32
  predict(x: DenseMatrixF32): Float32Array
  serialize(): Buffer
  static deserialize(data: Buffer): ElasticNetF32F32
}

export declare class ElasticNetF32U32 {
  constructor()
  static fit(x: DenseMatrixF32, y: Uint32Array, parameters: ElasticNetParameters): ElasticNetF32U32
  predict(x: DenseMatrixF32): Uint32Array
  serialize(): Buffer
  static deserialize(data: Buffer): ElasticNetF32U32
}

export declare class ElasticNetF64F64 {
  constructor()
  static fit(x: DenseMatrixF64, y: Float64Array, parameters: ElasticNetParameters): ElasticNetF64F64
  predict(x: DenseMatrixF64): Float64Array
  serialize(): Buffer
  static deserialize(data: Buffer): ElasticNetF64F64
}

export declare class ElasticNetParameters {
  constructor()
  withAlpha(alpha: number): void
  withL1Ratio(l1Ratio: number): void
  withNormalize(normalize: boolean): void
  withTol(tol: number): void
  withMaxIter(maxIter: number): void
}

export declare class Euclidianf32 {
  constructor()
  distance(x: Float32Array, y: Float32Array): number
}
export type EuclidianF32 = Euclidianf32

export declare class EuclidianF32DBSCANF32Parameters {
  withMinSamples(minSamples: number): void
  withAlgorithm(algorithm: KNNAlgorithmName): void
  withEps(eps: number): void
  constructor()
  static withDistanceHammingF32(distance: HammingF32): EuclidianF32DBSCANF32Parameters
}

export declare class Euclidianf64 {
  constructor()
  distance(x: Float64Array, y: Float64Array): number
}
export type EuclidianF64 = Euclidianf64

export declare class Euclidiani32 {
  constructor()
  distance(x: Int32Array, y: Int32Array): number
}
export type EuclidianI32 = Euclidiani32

export declare class Euclidiani64 {
  constructor()
  distance(x: BigInt64Array, y: BigInt64Array): number
}
export type EuclidianI64 = Euclidiani64

export declare class Euclidianu32 {
  constructor()
  distance(x: Uint32Array, y: Uint32Array): number
}
export type EuclidianU32 = Euclidianu32

export declare class Euclidianu64 {
  constructor()
  distance(x: BigUint64Array, y: BigUint64Array): number
}
export type EuclidianU64 = Euclidianu64

export declare class ExtraTreesRegressorF32F32 {
  static fit(x: DenseMatrixF32, y: Float32Array, parameters: ExtraTreesRegressorParameters): ExtraTreesRegressorF32F32
  predict(x: DenseMatrixF32): Float32Array
  serialize(): Buffer
  static deserialize(data: Buffer): ExtraTreesRegressorF32F32
}

export declare class ExtraTreesRegressorF32U32 {
  static fit(x: DenseMatrixF32, y: Uint32Array, parameters: ExtraTreesRegressorParameters): ExtraTreesRegressorF32U32
  predict(x: DenseMatrixF32): Uint32Array
  serialize(): Buffer
  static deserialize(data: Buffer): ExtraTreesRegressorF32U32
}

export declare class ExtraTreesRegressorF64F64 {
  static fit(x: DenseMatrixF64, y: Float64Array, parameters: ExtraTreesRegressorParameters): ExtraTreesRegressorF64F64
  predict(x: DenseMatrixF64): Float64Array
  serialize(): Buffer
  static deserialize(data: Buffer): ExtraTreesRegressorF64F64
}

export declare class ExtraTreesRegressorF64U64 {
  static fit(x: DenseMatrixF64, y: BigUint64Array, parameters: ExtraTreesRegressorParameters): ExtraTreesRegressorF64U64
  predict(x: DenseMatrixF64): BigUint64Array
  serialize(): Buffer
  static deserialize(data: Buffer): ExtraTreesRegressorF64U64
}

export declare class ExtraTreesRegressorParameters {
  constructor()
  withMaxDepth(maxDepth: number): void
  withMinSamplesLeaf(minSamplesLeaf: bigint): void
  withMinSamplesSplit(minSamplesSplit: bigint): void
  withNTrees(nTrees: number): void
  withM(m: number): void
  withKeepSamples(keepSamples: boolean): void
  withSeed(seed: number): void
}

export declare class F1F32 {
  constructor()
  getScore(yTrue: Float32Array, yPred: Float32Array): number
}
export type F1f32 = F1F32

export declare class F1F64 {
  constructor()
  getScore(yTrue: Float64Array, yPred: Float64Array): number
}
export type F1f64 = F1F64

export declare class GausianNBF32U32 {
  static fit(x: DenseMatrixF32, y: Uint32Array, parameters: BernoulliNBParametersF32): GausianNBF32U32
  predict(x: DenseMatrixF32): Uint32Array
  serialize(): Buffer
  static deserialize(data: Buffer): GausianNBF32U32
}

export declare class GausianNBF64U64 {
  static fit(x: DenseMatrixF64, y: BigUint64Array, parameters: BernoulliNBParametersF64): GausianNBF64U64
  predict(x: DenseMatrixF64): BigUint64Array
  serialize(): Buffer
  static deserialize(data: Buffer): GausianNBF64U64
}

export declare class GaussianNBF32U32 {
  static fit(x: DenseMatrixF32, y: Uint32Array, parameters: GaussianNBParameters): GaussianNBF32U32
  predict(x: DenseMatrixF32): Uint32Array
  serialize(): Buffer
  static deserialize(data: Buffer): GaussianNBF32U32
}

export declare class GaussianNBF64U64 {
  static fit(x: DenseMatrixF64, y: BigUint64Array, parameters: GaussianNBParameters): GaussianNBF64U64
  predict(x: DenseMatrixF64): BigUint64Array
  serialize(): Buffer
  static deserialize(data: Buffer): GaussianNBF64U64
}

export declare class GaussianNBParameters {
  constructor()
  withPriors(priors: Float64Array): void
}

export declare class Generator {
  makeBlobs(numSamples: number, numFeatures: number, numCenters: number): DatasetF32F32
  makeCircles(numSamples: number, factor: number, noise: number): DatasetF32U32
  makeMoons(numSamples: number, noise: number): DatasetF32U32
}

export declare class HammingF32 {
  constructor()
  distance(x: Float32Array, y: Float32Array): number
}

export declare class HammingF32DBSCANF32Parameters {
  withMinSamples(minSamples: number): void
  withAlgorithm(algorithm: KNNAlgorithmName): void
  withEps(eps: number): void
}

export declare class HammingF64 {
  constructor()
  distance(x: Float64Array, y: Float64Array): number
}

export declare class HammingI32 {
  constructor()
  distance(x: Int32Array, y: Int32Array): number
}

export declare class HammingI64 {
  constructor()
  distance(x: BigInt64Array, y: BigInt64Array): number
}

export declare class HammingU32 {
  constructor()
  distance(x: Uint32Array, y: Uint32Array): number
}

export declare class HammingU64 {
  constructor()
  distance(x: BigUint64Array, y: BigUint64Array): number
}

export declare class HCVScoreU32 {
  constructor()
  getScore(yTrue: Uint32Array, yPred: Uint32Array): number
}
export type HCVScoreu32 = HCVScoreU32

export declare class HCVScoreU64 {
  constructor()
  getScore(yTrue: BigUint64Array, yPred: BigUint64Array): number
}
export type HCVScoreu64 = HCVScoreU64

export declare class Iris {
  loadDataset(): DatasetF32U32
}

export declare class JsBoxedArrayF32Ref {

}

export declare class JsBoxedArrayF64Ref {

}

export declare class JsDenseMatrixF32Ref {
  matmul(other: JsDenseMatrixF32Ref): DenseMatrixF32
  transpose(): DenseMatrixF32
}

export declare class JsDenseMatrixF64Ref {
  matmul(other: JsDenseMatrixF64Ref): DenseMatrixF64
  transpose(): DenseMatrixF64
}

export declare class Kernels {
  static linear(): Kernels
  static rbf(gamma: number): Kernels
  static polynomial(gamma: number, degree: number): Kernels
  static sigmoid(gamma: number, coef0: number): Kernels
}

export declare class KFold {
  constructor()
  withNSplits(nSplits: number): void
}

export declare class KMeansF32F32 {
  static fit(x: DenseMatrixF32, parameters: KMeansParameters): KMeansF32F32
  predict(x: DenseMatrixF32): Float32Array
  serialize(): Buffer
  static deserialize(data: Buffer): KMeansF32F32
}

export declare class KMeansF32U32 {
  static fit(x: DenseMatrixF32, parameters: KMeansParameters): KMeansF32U32
  predict(x: DenseMatrixF32): Uint32Array
  serialize(): Buffer
  static deserialize(data: Buffer): KMeansF32U32
}

export declare class KMeansF64F64 {
  static fit(x: DenseMatrixF64, parameters: KMeansParameters): KMeansF64F64
  predict(x: DenseMatrixF64): Float64Array
  serialize(): Buffer
  static deserialize(data: Buffer): KMeansF64F64
}

export declare class KMeansF64U64 {
  static fit(x: DenseMatrixF64, parameters: KMeansParameters): KMeansF64U64
  predict(x: DenseMatrixF64): BigUint64Array
  serialize(): Buffer
  static deserialize(data: Buffer): KMeansF64U64
}

export declare class KMeansParameters {
  constructor()
  withMaxIter(maxIter: number): void
  withK(k: number): void
}

export declare class KNNClassifierF32U32 {
  static fit(x: DenseMatrixF32, y: Uint32Array): KNNClassifierF32U32
  predict(x: DenseMatrixF32): Uint32Array
}

export declare class KNNRegressorF32F32 {
  static fit(x: DenseMatrixF32, y: Float32Array): KNNRegressorF32F32
  predict(x: DenseMatrixF32): Float32Array
}

export declare class KNNRegressorF32U32 {
  static fit(x: DenseMatrixF32, y: Uint32Array): KNNRegressorF32U32
  predict(x: DenseMatrixF32): Uint32Array
}

export declare class KNNRegressorParametersF32EuclidianF32 {
  withK(k: number): void
  withAlgorithm(algorithm: KNNAlgorithmName): void
  withWeight(weight: KNNWeightFunction): void
  constructor()
  static withDistanceHammingF32(distance: HammingF32): KNNRegressorParametersF32EuclidianF32
}
export type EuclidianF32KNNRegressorParametersF32 = KNNRegressorParametersF32EuclidianF32

export declare class KNNRegressorParametersF32HammingF32 {
  withK(k: number): void
  withAlgorithm(algorithm: KNNAlgorithmName): void
  withWeight(weight: KNNWeightFunction): void
}
export type HammingF32KNNRegressorParametersF32 = KNNRegressorParametersF32HammingF32

export declare class LassoF32F32 {
  constructor()
  static fit(x: DenseMatrixF32, y: Float32Array, parameters: LassoParameters): LassoF32F32
  predict(x: DenseMatrixF32): Float32Array
  serialize(): Buffer
  static deserialize(data: Buffer): LassoF32F32
}

export declare class LassoF32U32 {
  constructor()
  static fit(x: DenseMatrixF32, y: Uint32Array, parameters: LassoParameters): LassoF32U32
  predict(x: DenseMatrixF32): Uint32Array
  serialize(): Buffer
  static deserialize(data: Buffer): LassoF32U32
}

export declare class LassoF64F64 {
  constructor()
  static fit(x: DenseMatrixF64, y: Float64Array, parameters: LassoParameters): LassoF64F64
  predict(x: DenseMatrixF64): Float64Array
  serialize(): Buffer
  static deserialize(data: Buffer): LassoF64F64
}

export declare class LassoParameters {
  constructor()
  withAlpha(alpha: number): void
  withNormalize(normalize: boolean): void
  withTol(tol: number): void
  withMaxIter(maxIter: number): void
}

export declare class LinearRegressionF32F32 {
  constructor()
  static fit(x: DenseMatrixF32, y: Float32Array, parameters: LinearRegressionParameters): LinearRegressionF32F32
  predict(x: DenseMatrixF32): Float32Array
  serialize(): Buffer
  static deserialize(data: Buffer): LinearRegressionF32F32
}

export declare class LinearRegressionF32U32 {
  constructor()
  static fit(x: DenseMatrixF32, y: Uint32Array, parameters: LinearRegressionParameters): LinearRegressionF32U32
  predict(x: DenseMatrixF32): Uint32Array
  serialize(): Buffer
  static deserialize(data: Buffer): LinearRegressionF32U32
}

export declare class LinearRegressionF64F64 {
  constructor()
  static fit(x: DenseMatrixF64, y: Float64Array, parameters: LinearRegressionParameters): LinearRegressionF64F64
  predict(x: DenseMatrixF64): Float64Array
  serialize(): Buffer
  static deserialize(data: Buffer): LinearRegressionF64F64
}

export declare class LinearRegressionParameters {
  constructor()
  withSolver(solver: LinearRegressionSolverName): void
}

export declare class LogisticRegressionF32U32 {
  constructor()
  static fit(x: DenseMatrixF32, y: Uint32Array, parameters: LogisticRegressionParametersF32): LogisticRegressionF32U32
  predict(x: DenseMatrixF32): Uint32Array
  serialize(): Buffer
  static deserialize(data: Buffer): LogisticRegressionF32U32
}

export declare class LogisticRegressionF64U64 {
  constructor()
  static fit(x: DenseMatrixF64, y: BigUint64Array, parameters: LogisticRegressionParametersF64): LogisticRegressionF64U64
  predict(x: DenseMatrixF64): BigUint64Array
  serialize(): Buffer
  static deserialize(data: Buffer): LogisticRegressionF64U64
}

export declare class LogisticRegressionParametersF32 {
  constructor()
  withAlpha(alpha: number): void
  withSolver(solver: LogisticRegressionSolverName): void
}

export declare class LogisticRegressionParametersF64 {
  constructor()
  withAlpha(alpha: number): void
  withSolver(solver: LogisticRegressionSolverName): void
}

export declare class MahalanobisF64 {
  constructor(data: DenseMatrixF64)
  distance(x: Float64Array, y: Float64Array): number
}

export declare class ManhattanF32 {
  constructor()
  distance(x: Float32Array, y: Float32Array): number
}

export declare class ManhattanF64 {
  constructor()
  distance(x: Float64Array, y: Float64Array): number
}

export declare class ManhattanI32 {
  constructor()
  distance(x: Int32Array, y: Int32Array): number
}

export declare class ManhattanI64 {
  constructor()
  distance(x: BigInt64Array, y: BigInt64Array): number
}

export declare class ManhattanU32 {
  constructor()
  distance(x: Uint32Array, y: Uint32Array): number
}

export declare class ManhattanU64 {
  constructor()
  distance(x: BigUint64Array, y: BigUint64Array): number
}

export declare class MeanAbsoluteErrorF32 {
  constructor()
  getScore(yTrue: Float32Array, yPred: Float32Array): number
}
export type MeanAbsoluteErrorf32 = MeanAbsoluteErrorF32

export declare class MeanAbsoluteErrorF64 {
  constructor()
  getScore(yTrue: Float64Array, yPred: Float64Array): number
}
export type MeanAbsoluteErrorf64 = MeanAbsoluteErrorF64

export declare class MeanSquareErrorF32 {
  constructor()
  getScore(yTrue: Float32Array, yPred: Float32Array): number
}
export type MeanSquareErrorf32 = MeanSquareErrorF32

export declare class MeanSquareErrorF64 {
  constructor()
  getScore(yTrue: Float64Array, yPred: Float64Array): number
}
export type MeanSquareErrorf64 = MeanSquareErrorF64

export declare class MinkowskiF32 {
  constructor(p: number)
  distance(x: Float32Array, y: Float32Array): number
}

export declare class MinkowskiF64 {
  constructor(p: number)
  distance(x: Float64Array, y: Float64Array): number
}

export declare class MinkowskiI32 {
  constructor(p: number)
  distance(x: Int32Array, y: Int32Array): number
}

export declare class MinkowskiI64 {
  constructor(p: number)
  distance(x: BigInt64Array, y: BigInt64Array): number
}

export declare class MinkowskiU32 {
  constructor(p: number)
  distance(x: Uint32Array, y: Uint32Array): number
}

export declare class MinkowskiU64 {
  constructor(p: number)
  distance(x: BigUint64Array, y: BigUint64Array): number
}

export declare class MultinomialNBParameters {
  constructor()
  withAlpha(alpha: number): void
  withPriors(priors: Float64Array): void
}

export declare class MultinomialNBU32U32 {
  static fit(x: DenseMatrixU32, y: Uint32Array, parameters: MultinomialNBParameters): MultinomialNBU32U32
  predict(x: DenseMatrixU32): Uint32Array
  serialize(): Buffer
  static deserialize(data: Buffer): MultinomialNBU32U32
}

export declare class MultinomialNBU32U64 {
  static fit(x: DenseMatrixU32, y: BigUint64Array, parameters: MultinomialNBParameters): MultinomialNBU32U64
  predict(x: DenseMatrixU32): BigUint64Array
  serialize(): Buffer
  static deserialize(data: Buffer): MultinomialNBU32U64
}

export declare class MultinomialNBU64U32 {
  static fit(x: DenseMatrixU64, y: Uint32Array, parameters: MultinomialNBParameters): MultinomialNBU64U32
  predict(x: DenseMatrixU64): Uint32Array
  serialize(): Buffer
  static deserialize(data: Buffer): MultinomialNBU64U32
}

export declare class MultinomialNBU64U64 {
  static fit(x: DenseMatrixU64, y: BigUint64Array, parameters: MultinomialNBParameters): MultinomialNBU64U64
  predict(x: DenseMatrixU64): BigUint64Array
  serialize(): Buffer
  static deserialize(data: Buffer): MultinomialNBU64U64
}

export declare class PCAF32 {
  constructor(data: DenseMatrixF32, parameters: PCAParameters)
  transform(x: DenseMatrixF32): DenseMatrixF32
  serialize(): Buffer
  static deserialize(data: Buffer): PCAF32
}

export declare class PCAF64 {
  constructor(data: DenseMatrixF64, parameters: PCAParameters)
  transform(x: DenseMatrixF64): DenseMatrixF64
  serialize(): Buffer
  static deserialize(data: Buffer): PCAF64
}

export declare class PCAParameters {
  constructor()
  withNComponents(nComponents: number): void
  set useCorrelationMatrix(useCorrelationMatrix: boolean)
}

export declare class PrecisionF32 {
  constructor()
  getScore(yTrue: Float32Array, yPred: Float32Array): number
}
export type Precisionf32 = PrecisionF32

export declare class PrecisionF64 {
  constructor()
  getScore(yTrue: Float64Array, yPred: Float64Array): number
}
export type Precisionf64 = PrecisionF64

export declare class R2F32 {
  constructor()
  getScore(yTrue: Float32Array, yPred: Float32Array): number
}
export type R2f32 = R2F32

export declare class R2U32 {
  constructor()
  getScore(yTrue: Uint32Array, yPred: Uint32Array): number
}
export type R2u32 = R2U32

export declare class R2U64 {
  constructor()
  getScore(yTrue: BigUint64Array, yPred: BigUint64Array): number
}
export type R2u64 = R2U64

export declare class RandomForestClassifierF32U32 {
  static fit(x: DenseMatrixF32, y: Uint32Array, parameters: RandomForestClassifierParameters): RandomForestClassifierF32U32
  predict(x: DenseMatrixF32): Uint32Array
  serialize(): Buffer
  static deserialize(data: Buffer): RandomForestClassifierF32U32
}

export declare class RandomForestClassifierF64U64 {
  static fit(x: DenseMatrixF64, y: BigUint64Array, parameters: RandomForestClassifierParameters): RandomForestClassifierF64U64
  predict(x: DenseMatrixF64): BigUint64Array
  serialize(): Buffer
  static deserialize(data: Buffer): RandomForestClassifierF64U64
}

export declare class RandomForestClassifierParameters {
  constructor()
  withCriterion(criterion: SplitCriterion): void
  withMaxDepth(maxDepth: number): void
  withMinSamplesLeaf(minSamplesLeaf: bigint): void
  withMinSamplesSplit(minSamplesSplit: bigint): void
  withNTrees(nTrees: number): void
  withM(m: number): void
  withKeepSamples(keepSamples: boolean): void
  withSeed(seed: number): void
}

export declare class RandomForestRegressorF32F32 {
  static fit(x: DenseMatrixF32, y: Float32Array, parameters: RandomForestRegressorParameters): RandomForestRegressorF32F32
  predict(x: DenseMatrixF32): Float32Array
  serialize(): Buffer
  static deserialize(data: Buffer): RandomForestRegressorF32F32
}

export declare class RandomForestRegressorF32U32 {
  static fit(x: DenseMatrixF32, y: Uint32Array, parameters: RandomForestRegressorParameters): RandomForestRegressorF32U32
  predict(x: DenseMatrixF32): Uint32Array
  serialize(): Buffer
  static deserialize(data: Buffer): RandomForestRegressorF32U32
}

export declare class RandomForestRegressorF64F64 {
  static fit(x: DenseMatrixF64, y: Float64Array, parameters: RandomForestRegressorParameters): RandomForestRegressorF64F64
  predict(x: DenseMatrixF64): Float64Array
  serialize(): Buffer
  static deserialize(data: Buffer): RandomForestRegressorF64F64
}

export declare class RandomForestRegressorF64U64 {
  static fit(x: DenseMatrixF64, y: BigUint64Array, parameters: RandomForestRegressorParameters): RandomForestRegressorF64U64
  predict(x: DenseMatrixF64): BigUint64Array
  serialize(): Buffer
  static deserialize(data: Buffer): RandomForestRegressorF64U64
}

export declare class RandomForestRegressorParameters {
  constructor()
  withMaxDepth(maxDepth: number): void
  withMinSamplesLeaf(minSamplesLeaf: bigint): void
  withMinSamplesSplit(minSamplesSplit: bigint): void
  withNTrees(nTrees: number): void
  withM(m: number): void
  withKeepSamples(keepSamples: boolean): void
  withSeed(seed: number): void
}

export declare class RecallF32 {
  constructor()
  getScore(yTrue: Float32Array, yPred: Float32Array): number
}
export type Recallf32 = RecallF32

export declare class RecallF64 {
  constructor()
  getScore(yTrue: Float64Array, yPred: Float64Array): number
}
export type Recallf64 = RecallF64

export declare class RidgeRegressionF32F32 {
  constructor()
  static fit(x: DenseMatrixF32, y: Float32Array, parameters: RidgeRegressionParametersF32): RidgeRegressionF32F32
  predict(x: DenseMatrixF32): Float32Array
  serialize(): Buffer
  static deserialize(data: Buffer): RidgeRegressionF32F32
}

export declare class RidgeRegressionF32U32 {
  constructor()
  static fit(x: DenseMatrixF32, y: Uint32Array, parameters: RidgeRegressionParametersF32): RidgeRegressionF32U32
  predict(x: DenseMatrixF32): Uint32Array
  serialize(): Buffer
  static deserialize(data: Buffer): RidgeRegressionF32U32
}

export declare class RidgeRegressionF64F64 {
  constructor()
  static fit(x: DenseMatrixF64, y: Float64Array, parameters: RidgeRegressionParametersF64): RidgeRegressionF64F64
  predict(x: DenseMatrixF64): Float64Array
  serialize(): Buffer
  static deserialize(data: Buffer): RidgeRegressionF64F64
}

export declare class RidgeRegressionParametersF32 {
  constructor()
  withAlpha(alpha: number): void
  withNormalize(normalize: boolean): void
  withSolver(solver: RidgeRegressionSolverName): void
}

export declare class RidgeRegressionParametersF64 {
  constructor()
  withAlpha(alpha: number): void
  withNormalize(normalize: boolean): void
  withSolver(solver: RidgeRegressionSolverName): void
}

export declare class SVCF32U32 {
  static setFitData(xRef: DenseMatrixF32, yRef: Uint32Array, parametersRef: SVCParametersF32U32): SVCF32U32
  fit(): void
  predict(xRef: DenseMatrixF32): Float32Array
}

export declare class SVCF64U64 {
  static setFitData(xRef: DenseMatrixF64, yRef: BigUint64Array, parametersRef: SVCParametersF64U64): SVCF64U64
  fit(): void
  predict(xRef: DenseMatrixF64): Float64Array
}

export declare class SVCParametersF32U32 {
  constructor()
  withEpoch(epoch: number): void
  withC(c: number): void
  withTol(tol: number): void
  withSeed(seed?: bigint | undefined | null): void
}

export declare class SVCParametersF64U64 {
  constructor()
  withEpoch(epoch: number): void
  withC(c: number): void
  withTol(tol: number): void
  withSeed(seed?: bigint | undefined | null): void
}

export declare class SVDF32 {
  constructor(data: DenseMatrixF32, parameters: SVDParameters)
  transform(x: DenseMatrixF32): DenseMatrixF32
  serialize(): Buffer
  static deserialize(data: Buffer): SVDF32
}

export declare class SVDF32DenseMatrixF32 {
  U(): JsDenseMatrixF32Ref
  V(): JsDenseMatrixF32Ref
  S(): DenseMatrixF32
}

export declare class SVDF64 {
  constructor(data: DenseMatrixF64, parameters: SVDParameters)
  transform(x: DenseMatrixF64): DenseMatrixF64
  serialize(): Buffer
  static deserialize(data: Buffer): SVDF64
}

export declare class SVDF64DenseMatrixF64 {
  U(): JsDenseMatrixF64Ref
  V(): JsDenseMatrixF64Ref
  S(): DenseMatrixF64
}

export declare class SVDParameters {
  constructor()
  withNComponents(nComponents: number): void
}

export declare class SVRF32 {
  static setFitData(xRef: DenseMatrixF32, yRef: Float32Array, parametersRef: SVRParametersF32): SVRF32
  fit(): void
  predict(xRef: DenseMatrixF32): Float32Array
}

export declare class SVRF64 {
  static setFitData(xRef: DenseMatrixF64, yRef: Float64Array, parametersRef: SVRParametersF64): SVRF64
  fit(): void
  predict(xRef: DenseMatrixF64): Float64Array
}

export declare class SVRParametersF32 {
  constructor()
  withEps(eps: number): void
  withC(c: number): void
  withTol(tol: number): void
  withKernel(kernel: Kernels): void
}

export declare class SVRParametersF64 {
  constructor()
  withEps(eps: number): void
  withC(c: number): void
  withTol(tol: number): void
  withKernel(kernel: Kernels): void
}

export declare function crossValidateElasticNetF32F32(xs: DenseMatrixF32, ys: Float32Array, parameters: ElasticNetParameters, cv: KFold, score: (arg0: Float32Array, arg1: Float32Array) => number): CrossValidationResult

export declare function crossValidateElasticNetF32U32(xs: DenseMatrixF32, ys: Uint32Array, parameters: ElasticNetParameters, cv: KFold, score: (arg0: Uint32Array, arg1: Uint32Array) => number): CrossValidationResult

export declare function crossValidateElasticNetF64F64(xs: DenseMatrixF64, ys: Float64Array, parameters: ElasticNetParameters, cv: KFold, score: (arg0: Float64Array, arg1: Float64Array) => number): CrossValidationResult

export declare function crossValidateLassoF32F32(xs: DenseMatrixF32, ys: Float32Array, parameters: LassoParameters, cv: KFold, score: (arg0: Float32Array, arg1: Float32Array) => number): CrossValidationResult

export declare function crossValidateLassoF32U32(xs: DenseMatrixF32, ys: Uint32Array, parameters: LassoParameters, cv: KFold, score: (arg0: Uint32Array, arg1: Uint32Array) => number): CrossValidationResult

export declare function crossValidateLassoF64F64(xs: DenseMatrixF64, ys: Float64Array, parameters: LassoParameters, cv: KFold, score: (arg0: Float64Array, arg1: Float64Array) => number): CrossValidationResult

export declare function crossValidateLogisticRegressionF32U32(xs: DenseMatrixF32, ys: Uint32Array, parameters: LogisticRegressionParametersF32, cv: KFold, score: (arg0: Uint32Array, arg1: Uint32Array) => number): CrossValidationResult

export declare function crossValidateLogisticRegressionF64U64(xs: DenseMatrixF64, ys: BigUint64Array, parameters: LogisticRegressionParametersF64, cv: KFold, score: (arg0: BigUint64Array, arg1: BigUint64Array) => number): CrossValidationResult

export declare const enum KNNAlgorithmName {
  LinearSearch = 0,
  CoverTree = 1
}

export declare const enum KNNWeightFunction {
  Uniform = 0,
  Distance = 1
}

export declare const enum LinearRegressionSolverName {
  Qr = 0,
  Svd = 1
}

export declare const enum LogisticRegressionSolverName {
  LBFGS = 0
}

export declare const enum RidgeRegressionSolverName {
  Cholesky = 0,
  Svd = 1
}

export declare const enum SplitCriterion {
  Gini = 0,
  Entropy = 1,
  ClassificationError = 2
}

export declare function trainTestSplitF32F32(x: DenseMatrixF32, y: Float32Array, testSize: number, shuffle: boolean, seed?: bigint | undefined | null): [DenseMatrixF32, DenseMatrixF32, Float32Array, Float32Array]

export declare function trainTestSplitF32U32(x: DenseMatrixF32, y: Uint32Array, testSize: number, shuffle: boolean, seed?: bigint | undefined | null): [DenseMatrixF32, DenseMatrixF32, Uint32Array, Uint32Array]

export declare function trainTestSplitF64F64(x: DenseMatrixF64, y: Float64Array, testSize: number, shuffle: boolean, seed?: bigint | undefined | null): [DenseMatrixF64, DenseMatrixF64, Float64Array, Float64Array]
