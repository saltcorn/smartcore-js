/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare class AccuracyF32 {
  constructor()
  getScore(yTrue: Float32Array, yPred: Float32Array): number
}
export type Accuracyf32 = AccuracyF32

export declare class AccuracyF64 {
  constructor()
  getScore(yTrue: Float64Array, yPred: Float64Array): number
}
export type Accuracyf64 = AccuracyF64

export declare class AccuracyU32 {
  constructor()
  getScore(yTrue: Uint32Array, yPred: Uint32Array): number
}
export type Accuracyu32 = AccuracyU32

export declare class Aucf32 {
  constructor()
  getScoreF32(yTrue: Float32Array, yPred: Float32Array): number
}
export type AUCF32 = Aucf32

export declare class Boston {
  loadDataset(): Datasetf32f32
}

export declare class BreastCancer {
  loadDataset(): Datasetf32u32
}

export declare class dataset {
  static boston(): Boston
  static breastCancer(): BreastCancer
  static diabetes(): Diabetes
  static digits(): Digits
  static generator(): Generator
  static iris(): Iris
}
export type Dataset = dataset

export declare class Datasetf32F32 {
  get data(): Float32Array
  get target(): Float32Array
  get numSamples(): number
  get numFeatures(): number
  get featureNames(): Array<string>
  get targetNames(): Array<string>
  get description(): string
  denseMatrix(columnMajor?: boolean | undefined | null): DenseMatrixf32
}
export type Datasetf32f32 = Datasetf32F32

export declare class Datasetf32U32 {
  get data(): Float32Array
  get target(): Uint32Array
  get numSamples(): number
  get numFeatures(): number
  get featureNames(): Array<string>
  get targetNames(): Array<string>
  get description(): string
  denseMatrix(columnMajor?: boolean | undefined | null): DenseMatrixf32
}
export type Datasetf32u32 = Datasetf32U32

export declare class DenseMatrixf32 {
  constructor(nrows: number, ncols: number, values: Float32Array, columnMajor?: boolean | undefined | null)
}

export declare class DenseMatrixf64 {
  constructor(nrows: number, ncols: number, values: Float64Array, columnMajor?: boolean | undefined | null)
}

export declare class Diabetes {
  loadDataset(): Datasetf32u32
}

export declare class Digits {
  loadDataset(): Datasetf32f32
}

export declare class Euclidianf32 {
  constructor()
  distance(x: Float32Array, y: Float32Array): number
}

export declare class Euclidianf64 {
  constructor()
  distance(x: Float64Array, y: Float64Array): number
}

export declare class Euclidiani32 {
  constructor()
  distance(x: Int32Array, y: Int32Array): number
}

export declare class Euclidiani64 {
  constructor()
  distance(x: BigInt64Array, y: BigInt64Array): number
}

export declare class Euclidianu32 {
  constructor()
  distance(x: Uint32Array, y: Uint32Array): number
}

export declare class Euclidianu64 {
  constructor()
  distance(x: BigUint64Array, y: BigUint64Array): number
}

export declare class F1F32 {
  constructor()
  getScoreF32(yTrue: Float32Array, yPred: Float32Array): number
}

export declare class Generator {
  makeBlobs(numSamples: number, numFeatures: number, numCenters: number): Datasetf32f32
  makeCircles(numSamples: number, factor: number, noise: number): Datasetf32u32
  makeMoons(numSamples: number, noise: number): Datasetf32u32
}

export declare class Hammingf32 {
  constructor()
  distance(x: Float32Array, y: Float32Array): number
}

export declare class Hammingf64 {
  constructor()
  distance(x: Float64Array, y: Float64Array): number
}

export declare class Hammingi32 {
  constructor()
  distance(x: Int32Array, y: Int32Array): number
}

export declare class Hammingi64 {
  constructor()
  distance(x: BigInt64Array, y: BigInt64Array): number
}

export declare class Hammingu32 {
  constructor()
  distance(x: Uint32Array, y: Uint32Array): number
}

export declare class Hammingu64 {
  constructor()
  distance(x: BigUint64Array, y: BigUint64Array): number
}

export declare class HcvScoreU32 {
  constructor()
  getScoreU32(yTrue: Uint32Array, yPred: Uint32Array): number
}
export type HCVScoreU32 = HcvScoreU32

export declare class Iris {
  loadDataset(): Datasetf32u32
}

export declare class KNNClassifierF32U32 {
  static fit(x: DenseMatrixf32, y: Uint32Array): KNNClassifierF32U32
  predict(x: DenseMatrixf32): Uint32Array
}
export type KNNClassifierf32u32 = KNNClassifierF32U32

export declare class Mahalanobisf64 {
  constructor(data: DenseMatrixf64)
  distance(x: Float64Array, y: Float64Array): number
}

export declare class Manhattanf32 {
  constructor()
  distance(x: Float32Array, y: Float32Array): number
}

export declare class Manhattanf64 {
  constructor()
  distance(x: Float64Array, y: Float64Array): number
}

export declare class Manhattani32 {
  constructor()
  distance(x: Int32Array, y: Int32Array): number
}

export declare class Manhattani64 {
  constructor()
  distance(x: BigInt64Array, y: BigInt64Array): number
}

export declare class Manhattanu32 {
  constructor()
  distance(x: Uint32Array, y: Uint32Array): number
}

export declare class Manhattanu64 {
  constructor()
  distance(x: BigUint64Array, y: BigUint64Array): number
}

export declare class MeanAbsoluteErrorF32 {
  constructor()
  getScoreF32(yTrue: Float32Array, yPred: Float32Array): number
}

export declare class MeanSquareErrorF32 {
  constructor()
  getScoreF32(yTrue: Float32Array, yPred: Float32Array): number
}

export declare class Minkowskif32 {
  constructor(p: number)
  distance(x: Float32Array, y: Float32Array): number
}

export declare class Minkowskif64 {
  constructor(p: number)
  distance(x: Float64Array, y: Float64Array): number
}

export declare class Minkowskii32 {
  constructor(p: number)
  distance(x: Int32Array, y: Int32Array): number
}

export declare class Minkowskii64 {
  constructor(p: number)
  distance(x: BigInt64Array, y: BigInt64Array): number
}

export declare class Minkowskiu32 {
  constructor(p: number)
  distance(x: Uint32Array, y: Uint32Array): number
}

export declare class Minkowskiu64 {
  constructor(p: number)
  distance(x: BigUint64Array, y: BigUint64Array): number
}

export declare class PCAF32 {
  constructor(data: DenseMatrixf32, parameters: PCAParameters)
  transform(x: DenseMatrixf32): DenseMatrixf32
}
export type PCAf32 = PCAF32

export declare class PCAF64 {
  constructor(data: DenseMatrixf64, parameters: PCAParameters)
  transform(x: DenseMatrixf64): DenseMatrixf64
}
export type PCAf64 = PCAF64

export declare class PCAParameters {
  constructor()
  withNComponents(nComponents: number): void
  set useCorrelationMatrix(useCorrelationMatrix: boolean)
}

export declare class PrecisionF32 {
  constructor()
  getScoreF32(yTrue: Float32Array, yPred: Float32Array): number
}

export declare class R2U32 {
  constructor()
  getScoreU32(yTrue: Uint32Array, yPred: Uint32Array): number
}

export declare class RecallF32 {
  constructor()
  getScoreF32(yTrue: Float32Array, yPred: Float32Array): number
}

export declare class RidgeRegressionF32F32 {
  constructor()
  static fit(x: DenseMatrixf32, y: Float32Array, parameters: RidgeRegressionParametersF32): RidgeRegressionF32F32
  predict(x: DenseMatrixf32): Float32Array
}
export type RidgeRegressionf32f32 = RidgeRegressionF32F32

export declare class RidgeRegressionF64F64 {
  constructor()
  static fit(x: DenseMatrixf64, y: Float64Array, parameters: RidgeRegressionParametersF64): RidgeRegressionF64F64
  predict(x: DenseMatrixf64): Float64Array
}
export type RidgeRegressionf64f64 = RidgeRegressionF64F64

export declare class RidgeRegressionParametersF32 {
  constructor()
  withAlpha(alpha: number): void
  withNormalize(normalize: boolean): void
  withSolver(solver: RidgeRegressionSolverName): void
}
export type RidgeRegressionParametersf32 = RidgeRegressionParametersF32

export declare class RidgeRegressionParametersF64 {
  constructor()
  withAlpha(alpha: number): void
  withNormalize(normalize: boolean): void
  withSolver(solver: RidgeRegressionSolverName): void
}
export type RidgeRegressionParametersf64 = RidgeRegressionParametersF64

export declare const enum RidgeRegressionSolverName {
  Cholesky = 0,
  Svd = 1
}

export declare function trainTestSplitF32F32(x: DenseMatrixf32, y: Float32Array, testSize: number, shuffle: boolean, seed?: bigint | undefined | null): [DenseMatrixf32, DenseMatrixf32, Float32Array, Float32Array]

export declare function trainTestSplitF64F64(x: DenseMatrixf64, y: Float64Array, testSize: number, shuffle: boolean, seed?: bigint | undefined | null): [DenseMatrixf64, DenseMatrixf64, Float64Array, Float64Array]
