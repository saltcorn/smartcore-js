/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare class AccuracyF32 {
  constructor()
  getScore(yTrue: Float32Array, yPred: Float32Array): number
}
export type Accuracyf32 = AccuracyF32

export declare class AccuracyF64 {
  constructor()
  getScore(yTrue: Float64Array, yPred: Float64Array): number
}
export type Accuracyf64 = AccuracyF64

export declare class AccuracyU32 {
  constructor()
  getScore(yTrue: Uint32Array, yPred: Uint32Array): number
}
export type Accuracyu32 = AccuracyU32

export declare class AUCF32 {
  constructor()
  getScore(yTrue: Float32Array, yPred: Float32Array): number
}
export type AUCf32 = AUCF32

export declare class AUCF64 {
  constructor()
  getScore(yTrue: Float64Array, yPred: Float64Array): number
}
export type AUCf64 = AUCF64

export declare class BernoulliNBParametersF32 {
  constructor()
  withPriors(priors: Float64Array): void
  withAlpha(alpha: number): void
  withBinarize(binarize: number): void
}

export declare class BernoulliNBParametersF64 {
  constructor()
  withPriors(priors: Float64Array): void
  withAlpha(alpha: number): void
  withBinarize(binarize: number): void
}

export declare class Boston {
  loadDataset(): DatasetF32F32
}

export declare class BreastCancer {
  loadDataset(): DatasetF32U32
}

export declare class CategoricalNBParameters {
  constructor()
  withAlpha(alpha: number): void
}

export declare class CategoricalNBU32 {
  static fit(x: DenseMatrixU32, y: Uint32Array, parameters: CategoricalNBParameters): CategoricalNBU32
  predict(x: DenseMatrixU32): Uint32Array
  serialize(): Buffer
  static deserialize(data: Buffer): CategoricalNBU32
}

export declare class CategoricalNBU64 {
  static fit(x: DenseMatrixU64, y: BigUint64Array, parameters: CategoricalNBParameters): CategoricalNBU64
  predict(x: DenseMatrixU64): BigUint64Array
  serialize(): Buffer
  static deserialize(data: Buffer): CategoricalNBU64
}

export declare class dataset {
  static boston(): Boston
  static breastCancer(): BreastCancer
  static diabetes(): Diabetes
  static digits(): Digits
  static generator(): Generator
  static iris(): Iris
}
export type Dataset = dataset

export declare class DatasetF32F32 {
  get data(): Float32Array
  get target(): Float32Array
  get numSamples(): number
  get numFeatures(): number
  get featureNames(): Array<string>
  get targetNames(): Array<string>
  get description(): string
  denseMatrix(columnMajor?: boolean | undefined | null): DenseMatrixF32
}

export declare class DatasetF32U32 {
  get data(): Float32Array
  get target(): Uint32Array
  get numSamples(): number
  get numFeatures(): number
  get featureNames(): Array<string>
  get targetNames(): Array<string>
  get description(): string
  denseMatrix(columnMajor?: boolean | undefined | null): DenseMatrixF32
}

export declare class DecisionTreeClassifierParameters {
  constructor()
  withCriterion(criterion: SplitCriterion): void
  withMaxDepth(maxDepth: number): void
  withMinSamplesLeaf(minSamplesLeaf: bigint): void
  withMinSamplesSplit(minSamplesSplit: bigint): void
}

export declare class DecisionTreeClassifierU32U32 {
  static fit(x: DenseMatrixU32, y: Uint32Array, parameters: DecisionTreeClassifierParameters): DecisionTreeClassifierU32U32
  predict(x: DenseMatrixU32): Uint32Array
  serialize(): Buffer
  static deserialize(data: Buffer): DecisionTreeClassifierU32U32
}

export declare class DecisionTreeClassifierU32U64 {
  static fit(x: DenseMatrixU32, y: BigUint64Array, parameters: DecisionTreeClassifierParameters): DecisionTreeClassifierU32U64
  predict(x: DenseMatrixU32): BigUint64Array
  serialize(): Buffer
  static deserialize(data: Buffer): DecisionTreeClassifierU32U64
}

export declare class DecisionTreeClassifierU64U32 {
  static fit(x: DenseMatrixU64, y: Uint32Array, parameters: DecisionTreeClassifierParameters): DecisionTreeClassifierU64U32
  predict(x: DenseMatrixU64): Uint32Array
  serialize(): Buffer
  static deserialize(data: Buffer): DecisionTreeClassifierU64U32
}

export declare class DecisionTreeClassifierU64U64 {
  static fit(x: DenseMatrixU64, y: BigUint64Array, parameters: DecisionTreeClassifierParameters): DecisionTreeClassifierU64U64
  predict(x: DenseMatrixU64): BigUint64Array
  serialize(): Buffer
  static deserialize(data: Buffer): DecisionTreeClassifierU64U64
}

export declare class DecisionTreeRegressorParameters {
  constructor()
  withMaxDepth(maxDepth: number): void
  withMinSamplesLeaf(minSamplesLeaf: bigint): void
  withMinSamplesSplit(minSamplesSplit: bigint): void
}

export declare class DecisionTreeRegressorU32U32 {
  static fit(x: DenseMatrixU32, y: Uint32Array, parameters: DecisionTreeRegressorParameters): DecisionTreeRegressorU32U32
  predict(x: DenseMatrixU32): Uint32Array
  serialize(): Buffer
  static deserialize(data: Buffer): DecisionTreeRegressorU32U32
}

export declare class DecisionTreeRegressorU32U64 {
  static fit(x: DenseMatrixU32, y: BigUint64Array, parameters: DecisionTreeRegressorParameters): DecisionTreeRegressorU32U64
  predict(x: DenseMatrixU32): BigUint64Array
  serialize(): Buffer
  static deserialize(data: Buffer): DecisionTreeRegressorU32U64
}

export declare class DecisionTreeRegressorU64U32 {
  static fit(x: DenseMatrixU64, y: Uint32Array, parameters: DecisionTreeRegressorParameters): DecisionTreeRegressorU64U32
  predict(x: DenseMatrixU64): Uint32Array
  serialize(): Buffer
  static deserialize(data: Buffer): DecisionTreeRegressorU64U32
}

export declare class DecisionTreeRegressorU64U64 {
  static fit(x: DenseMatrixU64, y: BigUint64Array, parameters: DecisionTreeRegressorParameters): DecisionTreeRegressorU64U64
  predict(x: DenseMatrixU64): BigUint64Array
  serialize(): Buffer
  static deserialize(data: Buffer): DecisionTreeRegressorU64U64
}

export declare class DenseMatrixF32 {
  constructor(nrows: number, ncols: number, values: Float32Array, columnMajor?: boolean | undefined | null)
  serialize(): Buffer
  static deserialize(data: Buffer): DenseMatrixF32
}

export declare class DenseMatrixF64 {
  constructor(nrows: number, ncols: number, values: Float64Array, columnMajor?: boolean | undefined | null)
  serialize(): Buffer
  static deserialize(data: Buffer): DenseMatrixF64
}

export declare class DenseMatrixU32 {
  constructor(nrows: number, ncols: number, values: Uint32Array, columnMajor?: boolean | undefined | null)
  serialize(): Buffer
  static deserialize(data: Buffer): DenseMatrixU32
}

export declare class DenseMatrixU64 {
  constructor(nrows: number, ncols: number, values: BigUint64Array, columnMajor?: boolean | undefined | null)
  serialize(): Buffer
  static deserialize(data: Buffer): DenseMatrixU64
}

export declare class Diabetes {
  loadDataset(): DatasetF32U32
}

export declare class Digits {
  loadDataset(): DatasetF32F32
}

export declare class ElasticNetF32F32 {
  constructor()
  static fit(x: DenseMatrixF32, y: Float32Array, parameters: ElasticNetParameters): ElasticNetF32F32
  predict(x: DenseMatrixF32): Float32Array
  serialize(): Buffer
  static deserialize(data: Buffer): ElasticNetF32F32
}

export declare class ElasticNetF32U32 {
  constructor()
  static fit(x: DenseMatrixF32, y: Uint32Array, parameters: ElasticNetParameters): ElasticNetF32U32
  predict(x: DenseMatrixF32): Uint32Array
  serialize(): Buffer
  static deserialize(data: Buffer): ElasticNetF32U32
}

export declare class ElasticNetF64F64 {
  constructor()
  static fit(x: DenseMatrixF64, y: Float64Array, parameters: ElasticNetParameters): ElasticNetF64F64
  predict(x: DenseMatrixF64): Float64Array
  serialize(): Buffer
  static deserialize(data: Buffer): ElasticNetF64F64
}

export declare class ElasticNetParameters {
  constructor()
  withAlpha(alpha: number): void
  withL1Ratio(l1Ratio: number): void
  withNormalize(normalize: boolean): void
  withTol(tol: number): void
  withMaxIter(maxIter: number): void
}

export declare class Euclidianf32 {
  constructor()
  distance(x: Float32Array, y: Float32Array): number
}
export type EuclidianF32 = Euclidianf32

export declare class Euclidianf64 {
  constructor()
  distance(x: Float64Array, y: Float64Array): number
}
export type EuclidianF64 = Euclidianf64

export declare class Euclidiani32 {
  constructor()
  distance(x: Int32Array, y: Int32Array): number
}
export type EuclidianI32 = Euclidiani32

export declare class Euclidiani64 {
  constructor()
  distance(x: BigInt64Array, y: BigInt64Array): number
}
export type EuclidianI64 = Euclidiani64

export declare class Euclidianu32 {
  constructor()
  distance(x: Uint32Array, y: Uint32Array): number
}
export type EuclidianU32 = Euclidianu32

export declare class Euclidianu64 {
  constructor()
  distance(x: BigUint64Array, y: BigUint64Array): number
}
export type EuclidianU64 = Euclidianu64

export declare class F1F32 {
  constructor()
  getScore(yTrue: Float32Array, yPred: Float32Array): number
}
export type F1f32 = F1F32

export declare class F1F64 {
  constructor()
  getScore(yTrue: Float64Array, yPred: Float64Array): number
}
export type F1f64 = F1F64

export declare class GausianNBF32U32 {
  static fit(x: DenseMatrixF32, y: Uint32Array, parameters: BernoulliNBParametersF32): GausianNBF32U32
  predict(x: DenseMatrixF32): Uint32Array
  serialize(): Buffer
  static deserialize(data: Buffer): GausianNBF32U32
}

export declare class GausianNBF64U64 {
  static fit(x: DenseMatrixF64, y: BigUint64Array, parameters: BernoulliNBParametersF64): GausianNBF64U64
  predict(x: DenseMatrixF64): BigUint64Array
  serialize(): Buffer
  static deserialize(data: Buffer): GausianNBF64U64
}

export declare class GaussianNBF32U32 {
  static fit(x: DenseMatrixF32, y: Uint32Array, parameters: GaussianNBParameters): GaussianNBF32U32
  predict(x: DenseMatrixF32): Uint32Array
  serialize(): Buffer
  static deserialize(data: Buffer): GaussianNBF32U32
}

export declare class GaussianNBF64U64 {
  static fit(x: DenseMatrixF64, y: BigUint64Array, parameters: GaussianNBParameters): GaussianNBF64U64
  predict(x: DenseMatrixF64): BigUint64Array
  serialize(): Buffer
  static deserialize(data: Buffer): GaussianNBF64U64
}

export declare class GaussianNBParameters {
  constructor()
  withPriors(priors: Float64Array): void
}

export declare class Generator {
  makeBlobs(numSamples: number, numFeatures: number, numCenters: number): DatasetF32F32
  makeCircles(numSamples: number, factor: number, noise: number): DatasetF32U32
  makeMoons(numSamples: number, noise: number): DatasetF32U32
}

export declare class HammingF32 {
  constructor()
  distance(x: Float32Array, y: Float32Array): number
}

export declare class HammingF64 {
  constructor()
  distance(x: Float64Array, y: Float64Array): number
}

export declare class HammingI32 {
  constructor()
  distance(x: Int32Array, y: Int32Array): number
}

export declare class HammingI64 {
  constructor()
  distance(x: BigInt64Array, y: BigInt64Array): number
}

export declare class HammingU32 {
  constructor()
  distance(x: Uint32Array, y: Uint32Array): number
}

export declare class HammingU64 {
  constructor()
  distance(x: BigUint64Array, y: BigUint64Array): number
}

export declare class HCVScoreU32 {
  constructor()
  getScore(yTrue: Uint32Array, yPred: Uint32Array): number
}
export type HCVScoreu32 = HCVScoreU32

export declare class HCVScoreU64 {
  constructor()
  getScore(yTrue: BigUint64Array, yPred: BigUint64Array): number
}
export type HCVScoreu64 = HCVScoreU64

export declare class Iris {
  loadDataset(): DatasetF32U32
}

export declare class Kernels {
  static linear(): Kernels
  static rbf(gamma: number): Kernels
  static polynomial(gamma: number, degree: number): Kernels
  static sigmoid(gamma: number, coef0: number): Kernels
}

export declare class KNNClassifierF32U32 {
  static fit(x: DenseMatrixF32, y: Uint32Array): KNNClassifierF32U32
  predict(x: DenseMatrixF32): Uint32Array
}

export declare class KNNRegressorF32F32 {
  static fit(x: DenseMatrixF32, y: Float32Array): KNNRegressorF32F32
  predict(x: DenseMatrixF32): Float32Array
}

export declare class KNNRegressorF32U32 {
  static fit(x: DenseMatrixF32, y: Uint32Array): KNNRegressorF32U32
  predict(x: DenseMatrixF32): Uint32Array
}

export declare class KNNRegressorParametersF32EuclidianF32 {
  withK(k: number): void
  withAlgorithm(algorithm: KNNAlgorithmName): void
  static withWeight(weight: KNNWeightFunction): KNNRegressorParametersF32EuclidianF32
  constructor()
  static withDistanceHammingF32(distance: HammingF32): KNNRegressorParametersF32EuclidianF32
}
export type EuclidianF32KNNRegressorParametersf32 = KNNRegressorParametersF32EuclidianF32

export declare class KNNRegressorParametersF32HammingF32 {
  withK(k: number): void
  withAlgorithm(algorithm: KNNAlgorithmName): void
  static withWeight(weight: KNNWeightFunction): KNNRegressorParametersF32HammingF32
}
export type HammingF32KNNRegressorParametersf32 = KNNRegressorParametersF32HammingF32

export declare class LassoF32F32 {
  constructor()
  static fit(x: DenseMatrixF32, y: Float32Array, parameters: LassoParameters): LassoF32F32
  predict(x: DenseMatrixF32): Float32Array
  serialize(): Buffer
  static deserialize(data: Buffer): LassoF32F32
}

export declare class LassoF32U32 {
  constructor()
  static fit(x: DenseMatrixF32, y: Uint32Array, parameters: LassoParameters): LassoF32U32
  predict(x: DenseMatrixF32): Uint32Array
  serialize(): Buffer
  static deserialize(data: Buffer): LassoF32U32
}

export declare class LassoF64F64 {
  constructor()
  static fit(x: DenseMatrixF64, y: Float64Array, parameters: LassoParameters): LassoF64F64
  predict(x: DenseMatrixF64): Float64Array
  serialize(): Buffer
  static deserialize(data: Buffer): LassoF64F64
}

export declare class LassoParameters {
  constructor()
  withAlpha(alpha: number): void
  withNormalize(normalize: boolean): void
  withTol(tol: number): void
  withMaxIter(maxIter: number): void
}

export declare class LinearRegressionF32F32 {
  constructor()
  static fit(x: DenseMatrixF32, y: Float32Array, parameters: LinearRegressionParameters): LinearRegressionF32F32
  predict(x: DenseMatrixF32): Float32Array
  serialize(): Buffer
  static deserialize(data: Buffer): LinearRegressionF32F32
}

export declare class LinearRegressionF32U32 {
  constructor()
  static fit(x: DenseMatrixF32, y: Uint32Array, parameters: LinearRegressionParameters): LinearRegressionF32U32
  predict(x: DenseMatrixF32): Uint32Array
  serialize(): Buffer
  static deserialize(data: Buffer): LinearRegressionF32U32
}

export declare class LinearRegressionF64F64 {
  constructor()
  static fit(x: DenseMatrixF64, y: Float64Array, parameters: LinearRegressionParameters): LinearRegressionF64F64
  predict(x: DenseMatrixF64): Float64Array
  serialize(): Buffer
  static deserialize(data: Buffer): LinearRegressionF64F64
}

export declare class LinearRegressionParameters {
  constructor()
  withSolver(solver: LinearRegressionSolverName): void
}

export declare class LogisticRegressionF32U32 {
  constructor()
  static fit(x: DenseMatrixF32, y: Uint32Array, parameters: LogisticRegressionParametersF32): LogisticRegressionF32U32
  predict(x: DenseMatrixF32): Uint32Array
  serialize(): Buffer
  static deserialize(data: Buffer): LogisticRegressionF32U32
}

export declare class LogisticRegressionF64U64 {
  constructor()
  static fit(x: DenseMatrixF64, y: BigUint64Array, parameters: LogisticRegressionParametersF64): LogisticRegressionF64U64
  predict(x: DenseMatrixF64): BigUint64Array
  serialize(): Buffer
  static deserialize(data: Buffer): LogisticRegressionF64U64
}

export declare class LogisticRegressionParametersF32 {
  constructor()
  withAlpha(alpha: number): void
  withSolver(solver: LogisticRegressionSolverName): void
}

export declare class LogisticRegressionParametersF64 {
  constructor()
  withAlpha(alpha: number): void
  withSolver(solver: LogisticRegressionSolverName): void
}

export declare class MahalanobisF64 {
  constructor(data: DenseMatrixF64)
  distance(x: Float64Array, y: Float64Array): number
}

export declare class ManhattanF32 {
  constructor()
  distance(x: Float32Array, y: Float32Array): number
}

export declare class ManhattanF64 {
  constructor()
  distance(x: Float64Array, y: Float64Array): number
}

export declare class ManhattanI32 {
  constructor()
  distance(x: Int32Array, y: Int32Array): number
}

export declare class ManhattanI64 {
  constructor()
  distance(x: BigInt64Array, y: BigInt64Array): number
}

export declare class ManhattanU32 {
  constructor()
  distance(x: Uint32Array, y: Uint32Array): number
}

export declare class ManhattanU64 {
  constructor()
  distance(x: BigUint64Array, y: BigUint64Array): number
}

export declare class MeanAbsoluteErrorF32 {
  constructor()
  getScore(yTrue: Float32Array, yPred: Float32Array): number
}
export type MeanAbsoluteErrorf32 = MeanAbsoluteErrorF32

export declare class MeanAbsoluteErrorF64 {
  constructor()
  getScore(yTrue: Float64Array, yPred: Float64Array): number
}
export type MeanAbsoluteErrorf64 = MeanAbsoluteErrorF64

export declare class MeanSquareErrorF32 {
  constructor()
  getScore(yTrue: Float32Array, yPred: Float32Array): number
}
export type MeanSquareErrorf32 = MeanSquareErrorF32

export declare class MeanSquareErrorF64 {
  constructor()
  getScore(yTrue: Float64Array, yPred: Float64Array): number
}
export type MeanSquareErrorf64 = MeanSquareErrorF64

export declare class MinkowskiF32 {
  constructor(p: number)
  distance(x: Float32Array, y: Float32Array): number
}

export declare class MinkowskiF64 {
  constructor(p: number)
  distance(x: Float64Array, y: Float64Array): number
}

export declare class MinkowskiI32 {
  constructor(p: number)
  distance(x: Int32Array, y: Int32Array): number
}

export declare class MinkowskiI64 {
  constructor(p: number)
  distance(x: BigInt64Array, y: BigInt64Array): number
}

export declare class MinkowskiU32 {
  constructor(p: number)
  distance(x: Uint32Array, y: Uint32Array): number
}

export declare class MinkowskiU64 {
  constructor(p: number)
  distance(x: BigUint64Array, y: BigUint64Array): number
}

export declare class MultinomialNBParameters {
  constructor()
  withAlpha(alpha: number): void
  withPriors(priors: Float64Array): void
}

export declare class MultinomialNBU32U32 {
  static fit(x: DenseMatrixU32, y: Uint32Array, parameters: MultinomialNBParameters): MultinomialNBU32U32
  predict(x: DenseMatrixU32): Uint32Array
  serialize(): Buffer
  static deserialize(data: Buffer): MultinomialNBU32U32
}

export declare class MultinomialNBU32U64 {
  static fit(x: DenseMatrixU32, y: BigUint64Array, parameters: MultinomialNBParameters): MultinomialNBU32U64
  predict(x: DenseMatrixU32): BigUint64Array
  serialize(): Buffer
  static deserialize(data: Buffer): MultinomialNBU32U64
}

export declare class MultinomialNBU64U32 {
  static fit(x: DenseMatrixU64, y: Uint32Array, parameters: MultinomialNBParameters): MultinomialNBU64U32
  predict(x: DenseMatrixU64): Uint32Array
  serialize(): Buffer
  static deserialize(data: Buffer): MultinomialNBU64U32
}

export declare class MultinomialNBU64U64 {
  static fit(x: DenseMatrixU64, y: BigUint64Array, parameters: MultinomialNBParameters): MultinomialNBU64U64
  predict(x: DenseMatrixU64): BigUint64Array
  serialize(): Buffer
  static deserialize(data: Buffer): MultinomialNBU64U64
}

export declare class PCAF32 {
  constructor(data: DenseMatrixF32, parameters: PCAParameters)
  transform(x: DenseMatrixF32): DenseMatrixF32
  serialize(): Buffer
  static deserialize(data: Buffer): PCAF32
}

export declare class PCAF64 {
  constructor(data: DenseMatrixF64, parameters: PCAParameters)
  transform(x: DenseMatrixF64): DenseMatrixF64
  serialize(): Buffer
  static deserialize(data: Buffer): PCAF64
}

export declare class PCAParameters {
  constructor()
  withNComponents(nComponents: number): void
  set useCorrelationMatrix(useCorrelationMatrix: boolean)
}

export declare class PrecisionF32 {
  constructor()
  getScore(yTrue: Float32Array, yPred: Float32Array): number
}
export type Precisionf32 = PrecisionF32

export declare class PrecisionF64 {
  constructor()
  getScore(yTrue: Float64Array, yPred: Float64Array): number
}
export type Precisionf64 = PrecisionF64

export declare class R2F32 {
  constructor()
  getScore(yTrue: Float32Array, yPred: Float32Array): number
}
export type R2f32 = R2F32

export declare class R2U32 {
  constructor()
  getScore(yTrue: Uint32Array, yPred: Uint32Array): number
}
export type R2u32 = R2U32

export declare class R2U64 {
  constructor()
  getScore(yTrue: BigUint64Array, yPred: BigUint64Array): number
}
export type R2u64 = R2U64

export declare class RandomForestRegressorF32F32 {
  static fit(x: DenseMatrixF32, y: Float32Array, parameters: RandomForestRegressorParameters): RandomForestRegressorF32F32
  predict(x: DenseMatrixF32): Float32Array
  serialize(): Buffer
  static deserialize(data: Buffer): RandomForestRegressorF32F32
}

export declare class RandomForestRegressorF32U32 {
  static fit(x: DenseMatrixF32, y: Uint32Array, parameters: RandomForestRegressorParameters): RandomForestRegressorF32U32
  predict(x: DenseMatrixF32): Uint32Array
  serialize(): Buffer
  static deserialize(data: Buffer): RandomForestRegressorF32U32
}

export declare class RandomForestRegressorF64F64 {
  static fit(x: DenseMatrixF64, y: Float64Array, parameters: RandomForestRegressorParameters): RandomForestRegressorF64F64
  predict(x: DenseMatrixF64): Float64Array
  serialize(): Buffer
  static deserialize(data: Buffer): RandomForestRegressorF64F64
}

export declare class RandomForestRegressorF64U64 {
  static fit(x: DenseMatrixF64, y: BigUint64Array, parameters: RandomForestRegressorParameters): RandomForestRegressorF64U64
  predict(x: DenseMatrixF64): BigUint64Array
  serialize(): Buffer
  static deserialize(data: Buffer): RandomForestRegressorF64U64
}

export declare class RandomForestRegressorParameters {
  constructor()
  withMaxDepth(maxDepth: number): void
  withMinSamplesLeaf(minSamplesLeaf: bigint): void
  withMinSamplesSplit(minSamplesSplit: bigint): void
  withNTrees(nTrees: number): void
  withM(m: number): void
  withKeepSamples(keepSamples: boolean): void
  withSeed(seed: number): void
}

export declare class RecallF32 {
  constructor()
  getScore(yTrue: Float32Array, yPred: Float32Array): number
}
export type Recallf32 = RecallF32

export declare class RecallF64 {
  constructor()
  getScore(yTrue: Float64Array, yPred: Float64Array): number
}
export type Recallf64 = RecallF64

export declare class RidgeRegressionF32F32 {
  constructor()
  static fit(x: DenseMatrixF32, y: Float32Array, parameters: RidgeRegressionParametersF32): RidgeRegressionF32F32
  predict(x: DenseMatrixF32): Float32Array
  serialize(): Buffer
  static deserialize(data: Buffer): RidgeRegressionF32F32
}

export declare class RidgeRegressionF32U32 {
  constructor()
  static fit(x: DenseMatrixF32, y: Uint32Array, parameters: RidgeRegressionParametersF32): RidgeRegressionF32U32
  predict(x: DenseMatrixF32): Uint32Array
  serialize(): Buffer
  static deserialize(data: Buffer): RidgeRegressionF32U32
}

export declare class RidgeRegressionF64F64 {
  constructor()
  static fit(x: DenseMatrixF64, y: Float64Array, parameters: RidgeRegressionParametersF64): RidgeRegressionF64F64
  predict(x: DenseMatrixF64): Float64Array
  serialize(): Buffer
  static deserialize(data: Buffer): RidgeRegressionF64F64
}

export declare class RidgeRegressionParametersF32 {
  constructor()
  withAlpha(alpha: number): void
  withNormalize(normalize: boolean): void
  withSolver(solver: RidgeRegressionSolverName): void
}

export declare class RidgeRegressionParametersF64 {
  constructor()
  withAlpha(alpha: number): void
  withNormalize(normalize: boolean): void
  withSolver(solver: RidgeRegressionSolverName): void
}

export declare class SVCF32U32 {
  static setFitData(xRef: DenseMatrixF32, yRef: Uint32Array, parametersRef: SVCParametersF32U32): SVCF32U32
  fit(): void
  predict(xRef: DenseMatrixF32): Float32Array
}

export declare class SVCF64U64 {
  static setFitData(xRef: DenseMatrixF64, yRef: BigUint64Array, parametersRef: SVCParametersF64U64): SVCF64U64
  fit(): void
  predict(xRef: DenseMatrixF64): Float64Array
}

export declare class SVCParametersF32U32 {
  constructor()
  withEpoch(epoch: number): void
  withC(c: number): void
  withTol(tol: number): void
  withSeed(seed?: bigint | undefined | null): void
}

export declare class SVCParametersF64U64 {
  constructor()
  withEpoch(epoch: number): void
  withC(c: number): void
  withTol(tol: number): void
  withSeed(seed?: bigint | undefined | null): void
}

export declare class SVRF32 {
  static setFitData(xRef: DenseMatrixF32, yRef: Float32Array, parametersRef: SVRParametersF32): SVRF32
  fit(): void
  predict(xRef: DenseMatrixF32): Float32Array
}

export declare class SVRF64 {
  static setFitData(xRef: DenseMatrixF64, yRef: Float64Array, parametersRef: SVRParametersF64): SVRF64
  fit(): void
  predict(xRef: DenseMatrixF64): Float64Array
}

export declare class SVRParametersF32 {
  constructor()
  withEps(eps: number): void
  withC(c: number): void
  withTol(tol: number): void
  withKernel(kernel: Kernels): void
}

export declare class SVRParametersF64 {
  constructor()
  withEps(eps: number): void
  withC(c: number): void
  withTol(tol: number): void
  withKernel(kernel: Kernels): void
}

export declare const enum KNNAlgorithmName {
  LinearSearch = 0,
  CoverTree = 1
}

export declare const enum KNNWeightFunction {
  Uniform = 0,
  Distance = 1
}

export declare const enum LinearRegressionSolverName {
  Qr = 0,
  Svd = 1
}

export declare const enum LogisticRegressionSolverName {
  LBFGS = 0
}

export declare const enum RidgeRegressionSolverName {
  Cholesky = 0,
  Svd = 1
}

export declare const enum SplitCriterion {
  Gini = 0,
  Entropy = 1,
  ClassificationError = 2
}

export declare function trainTestSplitF32F32(x: DenseMatrixF32, y: Float32Array, testSize: number, shuffle: boolean, seed?: bigint | undefined | null): [DenseMatrixF32, DenseMatrixF32, Float32Array, Float32Array]

export declare function trainTestSplitF32U32(x: DenseMatrixF32, y: Uint32Array, testSize: number, shuffle: boolean, seed?: bigint | undefined | null): [DenseMatrixF32, DenseMatrixF32, Uint32Array, Uint32Array]

export declare function trainTestSplitF64F64(x: DenseMatrixF64, y: Float64Array, testSize: number, shuffle: boolean, seed?: bigint | undefined | null): [DenseMatrixF64, DenseMatrixF64, Float64Array, Float64Array]
